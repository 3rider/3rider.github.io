[{"title":"Highcharts的一個Async Drilldown實例","url":"http://localhost:4000/2017/03/19/highcharts-async-drilldown/","content":"<p><a href=\"http://www.highcharts.com/\" target=\"_blank\" rel=\"external\">Highcharts</a>在使用簡易度和功能上在眾多圖表工具之中是比較平均的一個，而它的<a href=\"http://www.highcharts.com/docs/chart-concepts/drilldown\" target=\"_blank\" rel=\"external\">drilldown功能</a>是其中一個讓我選擇使用它的原因，drilldown的概念就像是<strong>逐層探索</strong>數據，由一個big picture再進入較細緻的部份，要顯示這樣的數據就需要像Highcharts這樣的工具協助了<br>&nbsp;</p>\n<h2 id=\"事前準備\"><a href=\"#事前準備\" class=\"headerlink\" title=\"事前準備\"></a>事前準備</h2><p>以下的例子用了這些模組</p>\n<ul>\n<li><a href=\"http://www.highcharts.com/download\" target=\"_blank\" rel=\"external\">Highcharts 5.0.9</a></li>\n<li><a href=\"http://jquery.com/download/\" target=\"_blank\" rel=\"external\">jQuery 3.1.1</a></li>\n<li>drilldown.js（包含在Highcharts的zip內）</li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"基本Drilldown\"><a href=\"#基本Drilldown\" class=\"headerlink\" title=\"基本Drilldown\"></a>基本Drilldown</h2><p>以下是一個用Highcharts建立的pie chart，試試點進去<code>水果</code>或是<code>飲品</code>的區域，試用一下drilldown功能吧</p>\n<p></p><p data-height=\"270\" data-theme-id=\"27846\" data-slug-hash=\"PpKLJQ\" data-default-tab=\"js,result\" data-user=\"auphone\" data-embed-version=\"2\" data-pen-title=\"Highcharts Normal Drilldown\" class=\"codepen\">See the Pen <a href=\"http://codepen.io/auphone/pen/PpKLJQ/\" target=\"_blank\" rel=\"external\">Highcharts Normal Drilldown</a> by auphone (<a href=\"http://codepen.io/auphone\" target=\"_blank\" rel=\"external\">@auphone</a>) on <a href=\"http://codepen.io\" target=\"_blank\" rel=\"external\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<p>&nbsp;</p>\n<h2 id=\"為甚麼要用Async？\"><a href=\"#為甚麼要用Async？\" class=\"headerlink\" title=\"為甚麼要用Async？\"></a>為甚麼要用Async？</h2><p>為甚麼我們要用Async drilldown呢？無論你叫它Async還是Lazy Load，目的一樣也是差不多的：</p>\n<ul>\n<li>讓頁面能較快初始化</li>\n<li>減少客戶端流量</li>\n<li>減少伺服器流量</li>\n<li>預防request size過大的問題</li>\n<li>更靈活</li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"Async-Drilldown\"><a href=\"#Async-Drilldown\" class=\"headerlink\" title=\"Async Drilldown\"></a>Async Drilldown</h2><p>當然用Async有好處也有壞處，如果圖表只有兩層，或許用一次request取得所有數據或許是比較好的方案，因為即時請求會比較慢，而且開發也比較麻煩，但試想像一個五層、甚至十層以上的圖表，每次初始化的時候就等於<strong>多讀取了十倍</strong>以上的數據，而且<strong>用戶也不一定會點進去</strong>第十層啊，所以總括而言Lazy Load在這裡應該是一個比較好的practice吧！以下是修改成Async的版本，結果應該跟上面的例子是一樣的，這邊在<code>getDrilldownData()</code>的時候模擬了一個0.25秒的請求</p>\n<p></p><p data-height=\"270\" data-theme-id=\"27846\" data-slug-hash=\"VpzNyG\" data-default-tab=\"js,result\" data-user=\"auphone\" data-embed-version=\"2\" data-pen-title=\"Highcharts Async Drilldown\" class=\"codepen\">See the Pen <a href=\"http://codepen.io/auphone/pen/VpzNyG/\" target=\"_blank\" rel=\"external\">Highcharts Async Drilldown</a> by auphone (<a href=\"http://codepen.io/auphone\" target=\"_blank\" rel=\"external\">@auphone</a>) on <a href=\"http://codepen.io\" target=\"_blank\" rel=\"external\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<p>&nbsp;</p>\n<h2 id=\"複數Series\"><a href=\"#複數Series\" class=\"headerlink\" title=\"複數Series\"></a>複數Series</h2><p>這是一個我在工作上花了一點時間才能做出來的，上面的例子都可以很容易地在Google找到，但當有複數的Series又需要Async的時候就是另一回事了，這情​​況很多時候會在棒形圖或折線圖之類圖表出現，而且出現率很高，就如以下例子比較兩間商店的產品，正常做法的drilldown只能顯示其中一間商店的資料，不論你按的是棒形圖或是商店。但我希望按<code>水果</code>連結時應該顯示商店A和商店B的水果產品，而不是其中一間，所以為了達到這個目的修改的地方也滿多的，主要就是用<code>e.points</code>判斷是按了一間商店、或是全部，然後我們需要由<code>addSeriesAsDrilldown()</code>改成<code>addSingleSeriesAsDrilldown()</code>才可以在drilldown內加入複數series</p>\n<p></p><p data-height=\"270\" data-theme-id=\"27846\" data-slug-hash=\"RpZOJv\" data-default-tab=\"js,result\" data-user=\"auphone\" data-embed-version=\"2\" data-pen-title=\"Highcharts Async Column Drilldown\" class=\"codepen\">See the Pen <a href=\"http://codepen.io/auphone/pen/RpZOJv/\" target=\"_blank\" rel=\"external\">Highcharts Async Column Drilldown</a> by auphone (<a href=\"http://codepen.io/auphone\" target=\"_blank\" rel=\"external\">@auphone</a>) on <a href=\"http://codepen.io\" target=\"_blank\" rel=\"external\">CodePen</a>.</p><p></p>\n<script async src=\"https://production-assets.codepen.io/assets/embed/ei.js\"></script>\n\n<p>&nbsp;</p>\n<h2 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h2><p>以上其中一些部份有點像hacking，雖然有很多類似的請求，但官方好像沒太大意欲進行這部份的優化，所以暫時就只能這樣吧…</p>\n","categories":[],"tags":[]},{"title":"Gitly.io．一個以性能優先、新推出的免費Git服務","url":"http://localhost:4000/2017/03/19/gitly-io-intro/","content":"<p><img src=\"https://3rider.com/wp-content/uploads/2017/03/gitly-io-screen.png\" alt=\"\"><br>幾天前Git又出現了新的競爭者，它就是<a href=\"https://gitly.io/\" target=\"_blank\" rel=\"external\">gitly</a>。它是由<a href=\"https://gitly.io/about\" target=\"_blank\" rel=\"external\">Alexander Medvednikov</a>開發的Git版本控制系統，而重點是它可以<strong>自行託管</strong>，而且是<strong>Open Source</strong>的，雖然以上兩項暫時都還沒開放，但作者已經表示會一個月內、2017年4月10日推出這些功能。<br>&nbsp;</p>\n<h2 id=\"gitly的優點\"><a href=\"#gitly的優點\" class=\"headerlink\" title=\"gitly的優點\"></a>gitly的優點</h2><ul>\n<li><strong>免費</strong></li>\n<li>介面簡單，容易操作</li>\n<li><strong>免安裝</strong>，它聲稱只需要10秒便設定好託管，雖然還沒開放沒辦法測試，但用雲端版的確是蠻快的</li>\n<li>無須伺服器或資料庫</li>\n<li>記憶體需求低，256MB的配置也能跑出高效能</li>\n<li><p>便宜的代管方案，<strong>無限private repository</strong>，5個用戶以上才要收費，而且每個額外用戶每月只要<strong>$1美金</strong></p>\n<p>但由於這還是alpha版本，所以有<strong>很多功能未完整</strong>，不過創辦人指出一些核心功能例如SSH、Pull Request、Forking等等將會在2星期內補上，到底可不可行就要到時候才知道了。但目前來看創辦人的回應速度還滿快的，而且也很常於接受其他人意見和請求，為自己增添了不少印象分，就以上來說我對這個新公司的期望還是很高的。</p>\n</li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"gitly適合你嗎？\"><a href=\"#gitly適合你嗎？\" class=\"headerlink\" title=\"gitly適合你嗎？\"></a>gitly適合你嗎？</h2><p>暫時真的只能當試用階段，可以看出來它有很大的轉變空間，但無限private repo應該是不會變的了，相比其他類似收費制度的公司例如<a href=\"https://bitbucket.org/product\" target=\"_blank\" rel=\"external\">Bitbucket</a>，gitly一定是比較快，而且比其他公司都便宜，從自行託管來看設定和性能上應該會比<a href=\"https://about.gitlab.com/\" target=\"_blank\" rel=\"external\">GitLab</a>來的好。   所以如果只是一些<strong>個人項目</strong>可以考慮一下轉到gitly，而且原創者已經把repo-mirroring納入下一批更新內，可以同步現有和新的repo，不想用的時候也可以立即換回去；Open Source的項目需要龐大的社群協助，就不太適合轉到這邊了；至於考慮用途的項目的還是等到正式版本再考慮吧！</p>\n","categories":[],"tags":[]},{"title":"Wordpress備份自己做，從Google VM直接備份至Cloud Storage！","url":"http://localhost:4000/2017/03/19/wordpress-gcp-backup/","content":"<p>CMS有不少備份工具可以選擇，尤其是Wordpress這類歷史悠久的CMS，備份插件之多讓你無從入手，但是很多插件工具都<strong>不是免費</strong>讓你使用的，特別是備份到Google Cloud Storage（GCS）這類較新的空間，目前只找到一個最像樣的由<a href=\"https://updraftplus.com/\" target=\"_blank\" rel=\"external\">UpdraftPlus</a>提供的插件，它支援GCS的收費是<strong>每個網域$15美金</strong>，雖然價錢還算合理，但工程師的自尊不容許我沒試過便直接付錢買下去（<del datetime=\"2017-03-08T15:28:22+00:00\">雖然最後還是買了</del>），所以花了點下班休息時間自己試做一下。<br>&nbsp;</p>\n<h2 id=\"一﹒準備工作\"><a href=\"#一﹒準備工作\" class=\"headerlink\" title=\"一﹒準備工作\"></a>一﹒準備工作</h2><p>這次還是用我熟悉的Node.js，沒有Node可以到<a href=\"https://3rider.com/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E5%AE%89%E8%A3%9Dnode-js%EF%BC%8C%E7%B7%A8%E5%AF%AB%E7%AC%AC%E4%B8%80%E5%80%8Bhello-world%EF%BC%81/\" target=\"_blank\" rel=\"external\">這裡看看</a>安裝方法，而且這次是直接從VM備份到GSC，所以很方便不需要credential認證</p>\n<ul>\n<li>安裝好Node.js</li>\n<li>一個Google的VM instance</li>\n<li>Google Cloud Platform（GCP）開放Storage服務權限</li>\n<li>一個GSC Bucket</li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"二﹒開放VM服務範圍（scope）\"><a href=\"#二﹒開放VM服務範圍（scope）\" class=\"headerlink\" title=\"二﹒開放VM服務範圍（scope）\"></a>二﹒開放VM服務範圍（scope）</h2><p>先到你的VM控制面版，拉到最下面查看啟動了的服務，如果顯示是這樣，表示已經啟動所有權限了，所以請跳過這步驟<br><img src=\"https://3rider.com/wp-content/uploads/2017/03/google-vm-4.png\" alt=\"\"></p>\n<p>如果<strong>Storage</strong>狀態是<code>Enable</code>，也可跳過這步驟，但是如果跟下圖一樣只有讀取（Read Only）權限便要繼續進行設定<br><img src=\"https://3rider.com/wp-content/uploads/2017/03/google-vm-2.png\" alt=\"\"></p>\n<p>假設你的VM沒有開啟Storage權限，先按Stop關掉你的VM，然後按Edit編輯VM的設置<br><img src=\"https://3rider.com/wp-content/uploads/2017/03/google-vm-1.png\" alt=\"\"></p>\n<p>我個人是蠻怕麻煩的，反正有防火牆，所以便直接開啟所有服務權限，最後儲存再重啟你的VM便完成了<br><img src=\"https://3rider.com/wp-content/uploads/2017/03/google-vm-3.png\" alt=\"\"></p>\n<p>&nbsp;</p>\n<h2 id=\"三﹒編寫備份程式\"><a href=\"#三﹒編寫備份程式\" class=\"headerlink\" title=\"三﹒編寫備份程式\"></a>三﹒編寫備份程式</h2><p>怎樣建立一個project就不多說了，可以直接到<a href=\"https://github.com/3rider/wp-gcp-backup\" target=\"_blank\" rel=\"external\">我的GitHub</a>下載原碼<br>&nbsp;<br><strong>NPM模組</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"json\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"json\">&quot;dependencies&quot;: {\n    &quot;@google-cloud/storage&quot;: &quot;^0.7.0&quot;,\n    &quot;adm-zip&quot;: &quot;^0.4.7&quot;,\n    &quot;archiver&quot;: &quot;^1.3.0&quot;,\n    &quot;bluebird&quot;: &quot;^3.5.0&quot;,\n    &quot;cron&quot;: &quot;^1.2.1&quot;,\n    &quot;fast-crc32c&quot;: &quot;^1.0.4&quot;,\n    &quot;moment&quot;: &quot;^2.17.1&quot;,\n    &quot;mysqldump&quot;: &quot;^1.3.1&quot;\n}\n</code></pre>\n<p>&nbsp;<br>CoffeeScript原碼</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>_         = require &#39;lodash&#39; \nfs        = require &#39;fs&#39;\npath      = require &#39;path&#39;\nmoment    = require &#39;moment&#39;\narchiver  = require &#39;archiver&#39;\nmysqlDump = require &#39;mysqldump&#39;\nPromise   = require &#39;bluebird&#39;\nCronJob   = require(&#39;cron&#39;).CronJob\n\n# GCP\ngcs = require(&#39;@google-cloud/storage&#39;)()\nbucket = gcs.bucket &#39;MY-GCS-BUCKET&#39; # Your bucket name\n\n# Params\ntimezone      = &#39;Asia/Hong_Kong&#39; # Cron job timezone\ncronInterval  = &#39;0 0 4 * * *&#39; # Run every day at 4a.m.\nbakFilename   = &quot;backup-#{moment().format(&quot;YYYYMMDDHH&quot;)}.zip&quot;\n\n# Config\nconfig =\n  out: &quot;#{__dirname}/#{bakFilename}&quot; # Temporary zipped backup path\n  wordpress:\n    dir: &#39;/var/www/html/wp&#39; # Wordpress root dir\n  mysql:\n    host: &#39;localhost&#39;\n    user: &#39;root&#39;\n    password: &#39;&#39;\n    database: &#39;wp&#39;\n    dest: &quot;#{__dirname}/wp.sql&quot; # Temporary sql dump file path\n\n# Dump Mysql\nbackupMysql = -&gt;\n  return new Promise (rs, rj) -&gt;\n    mysqlDump config.mysql, (err) -&gt;\n      return rj err if err?\n      rs config.mysql.dest\n\n# Backup Wordpress with MySQL\ncreateZip = (sqlPath) -&gt;\n  return new Promise (rs, rj) -&gt;\n    output  = fs.createWriteStream config.out\n    archive = archiver &#39;zip&#39;,\n      store: true\n      cwd: &#39;wordpress&#39;\n    archive.pipe output\n\n    # Listener\n    output.on &#39;close&#39;, -&gt;\n      console.log &quot;#{archive.pointer()} total bytes&quot;\n      return rs()\n\n    output.on &#39;error&#39;, (err) -&gt;\n      return rj err\n\n    # Add SQL Dump\n    archive.file sqlPath,\n      name: &quot;#{config.mysql.database}.sql&quot;\n\n    # Add Wordpress Directories\n    archive.directory config.wordpress.dir, &#39;/wordpress&#39;\n\n    # Finalize Zip\n    archive.finalize()\n\n# Push to Google Cloud Storage\npushToGCS = -&gt;\n  return new Promise (rs, rj) -&gt;\n    file = bucket.file bakFilename\n    fs\n      .createReadStream config.out\n      .pipe file.createWriteStream({ gzip: true })\n      .on &#39;error&#39;, (err) -&gt;\n        return rj err\n      .on &#39;finish&#39;, -&gt;\n        console.log &#39;Pushed to GCS&#39;\n        return rs()\n\n# Cron Job\njob = new CronJob \n  cronTime: cronInterval\n  onTick: -&gt;\n    console.log &#39;Dumping MySQL database...&#39;\n    backupMysql()\n      .then (sqlPath) -&gt;\n        console.log &#39;Zipping Wordpress directory...&#39;\n        return createZip sqlPath\n      .then -&gt;\n        console.log &quot;Pushing #{bakFilename} to Google cloud storage...&quot;\n        return pushToGCS()\n      .then -&gt;\n        console.log &#39;Backup success!&#39;\n      .catch (err) -&gt;\n        console.error err\n      .finally -&gt;\n        console.log &#39;Deleting local backup files...&#39;\n        try\n          fs.unlinkSync config.out\n          fs.unlinkSync config.mysql.dest\n  start: false\n  timezone: timezone\n\n# Start Job\njob.start()\nconsole.log &#39;Monitoring...&#39;\n</code></pre><p>&nbsp;<br>簡略說明一下，首先<code># GCP</code>用作設定GCS的bucket名稱，請<strong>預先在GCS建立一個bucket</strong>，這篇沒有包括建立bucket的教程；<code># Params</code>進行cron job的設定，預設了<strong>每天凌晨四點</strong>進行備份；而<code># Config</code>則設定了MySQL的連接資料，請自行修改這些設定，最後每次作業的先後次序是：</p>\n<ol>\n<li>備份MySQL</li>\n<li>把剛備份好的MySQL連同Wordpress壓縮到<code>config.out</code>內指定的位置</li>\n<li>把壓縮檔傳送至設定好的bucket內</li>\n<li>最後刪除本地的備份檔案</li>\n</ol>\n<p>&nbsp;</p>\n<h2 id=\"四﹒運行\"><a href=\"#四﹒運行\" class=\"headerlink\" title=\"四﹒運行\"></a>四﹒運行</h2><p>權限設定好了，程式也有了，再來就是運行的部份了，這裡建議大家使用<a href=\"https://github.com/Unitech/pm2\" target=\"_blank\" rel=\"external\">pm2</a>，它是一個強大的Node管理系統</p>\n<pre><code>npm install pm2 -g\n</code></pre><p>安裝好了以後用<code>pm2</code>執行index.coffee，順便為程序命名</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">pm2 start index.coffee --name wp-backup\n</code></pre>\n<p>然後只要等到設定好的時間，系統便會自動進行備份了，運行的log大概是以下這樣，成功了便可以到GCS查看上傳了的備份檔案</p>\n<pre><code>Monitoring...\nDumping MySQL database...\nZipping Wordpress directory...\n3811909 total bytes\nPushing backup-2017030900.zip to Google cloud storage...\nPushed to GCS\nBackup success!\nDeleting local backup files...\n</code></pre><p>&nbsp;</p>\n<h2 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h2><p>到最後就如上面提及到，我還是買了UpdraftPlus的插件，因為我用的是最便宜VM，而沒記錯它只有0.6GB記憶體和1個共用核心，所以基本上運行了LEMP以後也沒剩多少資源讓我再運行一個Node.js的程序了，這是我花了幾小時設定好以上所有東西以後才發覺的，無奈我不是很熟悉PHP啊…</p>\n","categories":[],"tags":[]},{"title":"談CoffeeScript的未來，是否被ES6趕盡殺絕？","url":"http://localhost:4000/2017/03/19/coffee-future/","content":"<p>用CoffeeScript已經好幾年了，只要有我參與的JS項目或多或少都會有Coffee出現，可是2016年發佈的<a href=\"http://es6-features.org/#Constants\" target=\"_blank\" rel=\"external\">ES6</a>是一眾Coffee愛好者<strong>最壞的消息</strong>，因為Coffee缺乏商業價值，community也比較狹窄，所以不難想像Coffee已經沒能力跟上ES6這個大改動了。那麼Coffee的未來到底是怎樣呢？最近常常被問到「<strong>用Coffee真的沒問題嗎？</strong>」這類令人痛心的說話，雖然不情願但還是做了一下資料搜集，然後很快地搜到這篇<a href=\"https://github.com/coffeescript6/discuss\" target=\"_blank\" rel=\"external\">CoffeeScript 6.0 discuss</a>的文章，看來還是很多人關心這個問題嘛，點進去後我看到這個…<br><img src=\"https://3rider.com/wp-content/uploads/2017/03/rip-coffee.png\" alt=\"\"><br>&nbsp;<br>我的心臟頓時冷了一下，我立刻代入了<a href=\"https://zh.wikipedia.org/wiki/%E9%BA%A5%E7%94%B0%E6%8D%95%E6%89%8B\" target=\"_blank\" rel=\"external\">麥田捕手</a>裡Holden的心境，我憎恨這個社會！為甚麼要這樣對我的Coffee！可是當我忍痛繼續看下去時，卻讓我看到了希望，就是<a href=\"https://rawgit.com/jashkenas/coffeescript/2/docs/v2/index.html\" target=\"_blank\" rel=\"external\">CoffeeScript 2.0</a>！我立刻收回剛剛說Coffee沒能力的話，心境也瞬間變回桑地亞哥，但這次不是在夢境，而是我真的看到獅子了！<br>&nbsp;</p>\n<h2 id=\"CoffeeScript-2-0\"><a href=\"#CoffeeScript-2-0\" class=\"headerlink\" title=\"CoffeeScript 2.0\"></a>CoffeeScript 2.0</h2><p>CoffeeScript 2.0是<strong>根據ES2015+的功能來開發</strong>的，雖然它某些部份不能向後兼容以往的Coffee版本，但總比不兼容ES6+來得好，就是說我以後可以<strong>理直氣壯地跟別人說我用CoffeeScript開發</strong>了！讓我們期待它的發展吧，每次看到Coffee這種syntax的比較我就知道自己沒辦法放棄它啊！<br><img src=\"https://3rider.com/wp-content/uploads/2017/03/coffee-compare.png\" alt=\"\"></p>\n<p>無論別人怎樣貶低Coffee，只要有愛就行了！好Coffee，不用嗎？</p>\n","categories":[],"tags":[]},{"title":"看完Google提供的便宜方案，我決定從AWS轉到GCP了！","url":"http://localhost:4000/2017/03/19/aws-to-gcp/","content":"<p>第一次聽到<a href=\"https://cloud.google.com/\" target=\"_blank\" rel=\"external\">GCP（Google Cloud Platform）</a>大概是2016年初左右吧，因為機緣巧合在研究Big Data的時候看到它的Big Query，而且還能夠試用，我當然不會放過啊，當時忘記了是30天還是60天試用，提供的額度跟現在一樣是$300美金，試了一段時間發現它有些缺點不能達到我的項目要求，所以就沒有再用了。那時候對它的印象就是介面很好看，然後它的<a href=\"https://cloud.google.com/compute/\" target=\"_blank\" rel=\"external\">Computer Engine</a>（Google的虛擬機器）很快，自帶的網頁版SSH很好用，總之印象還是很好的，但可能是一直在用AWS，Big Query又不太用得到，而且當時個人方面也沒實際需要用到一個VM，所以也不太上心。<br>&nbsp;</p>\n<h2 id=\"轉成GCP的契機\"><a href=\"#轉成GCP的契機\" class=\"headerlink\" title=\"轉成GCP的契機\"></a>轉成GCP的契機</h2><p>寫這個網誌一開始的時候也是用AWS的，直至幾天前在Hacker News看到這篇<a href=\"https://news.ycombinator.com/item?id=13755673\" target=\"_blank\" rel=\"external\">Ask HN: Is S3 down?</a>，當然文章的內容不是重點，看完第一個回覆真的讓我一頭霧水，原本是在問AWS的問題，卻來了一堆回覆討論GCP，然後剛好我很閒（在上班）看看他們討論些甚麼，發現很多關於價錢的比較，看到之後我二話不說立刻到GCP查價目表，一看之下真的嚇了我一大跳，規格差不多的VM價錢比AWS<strong>便宜了一倍</strong>，這裡不是說AWS貴，但是<strong>GCP真的很划算</strong>，尤其是我這些只用網頁寄存的用戶，經過一番研究（在上班）後，最後我決定在GCP設定一台VM，然後為這網誌搬家了。但話雖如此，其實AWS跟GCP各有好處，只是我選擇了GCP作個人用途，而工作上我還是在用AWS的！<del datetime=\"2017-03-06T12:25:01+00:00\">因為買了RI（Reserved Instance）…</del><br>&nbsp;</p>\n<h2 id=\"免費方案比較\"><a href=\"#免費方案比較\" class=\"headerlink\" title=\"免費方案比較\"></a>免費方案比較</h2><p><strong>Google Cloud Platform</strong></p>\n<ul>\n<li>需要登記信用卡</li>\n<li>體驗60天</li>\n<li>$300美金限額</li>\n<li>比較寬鬆的服務限制，直至花光限額或過了60天</li>\n</ul>\n<p><strong>AWS</strong></p>\n<ul>\n<li>需要登記信用卡</li>\n<li>體驗一年</li>\n<li>沒有限額</li>\n<li>只能用<a href=\"https://aws.amazon.com/tw/free/\" target=\"_blank\" rel=\"external\">免費方案包含</a>的服務</li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"價錢比較\"><a href=\"#價錢比較\" class=\"headerlink\" title=\"價錢比較\"></a>價錢比較</h2><p>以下我只列出最基本的On-Demand收費，就這樣已經看出差別了，就以普遍的單核3.75GB記憶體作比較，GCP每小時$0.055，AWS則要$0.098，差不多相差了<strong>一倍</strong>！<br>&nbsp;<br><strong>Google Cloud Platform</strong><br><img src=\"https://3rider.com/wp-content/uploads/2017/03/gpc-pricing.png\" alt=\"\"> </p>\n<p><strong>AWS</strong><br><img src=\"https://3rider.com/wp-content/uploads/2017/03/aws-pricing.png\" alt=\"\"></p>\n<p>&nbsp;</p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>因為它們提供的服務太多，這裡不逐一比較了，反正兩邊都能免費試用，看自己的需要選擇吧</p>\n<ul>\n<li>AWS<strong>每張信用卡</strong>有<strong>一年免費</strong>，所以可以免費讓你用很久</li>\n<li>GPC的限額制可以讓你免費<strong>測試較高效能</strong>的服務，AWS只能用比較基本的服務</li>\n<li>兩邊的監測系統差不多，個人覺得GCP介面的比較人性化</li>\n<li>兩邊都自帶網頁版SSH，但是AWS需要用Java，而且用起來比較慢</li>\n<li>AWS提供<strong>較多地區選擇</strong>，特別是海外，但是<strong>GCP有台灣</strong>而AWS最近的只有日本</li>\n<li>如果不預付暫時來看是<strong>GCP比較便宜</strong></li>\n<li>某M公司就不說了，介面不好用、性能慢、收費貴、下刪一千字…</li>\n</ul>\n","categories":[],"tags":[]},{"title":"免費把網頁升級至HTTPs！Let's Encrypt + Nginx的SSL安裝教學","url":"http://localhost:4000/2017/03/19/free-ssl/","content":"<p><a href=\"https://letsencrypt.org/\" target=\"_blank\" rel=\"external\">Let’s Encrypt</a>已經推出一段時間了，它是一個多方認可的HTTP加密服務，而且還是<strong>免費</strong>的，這下我們不用再支付昂貴的年費了！<br>&nbsp;</p>\n<h2 id=\"為麼要用SSL？\"><a href=\"#為麼要用SSL？\" class=\"headerlink\" title=\"為麼要用SSL？\"></a>為麼要用SSL？</h2><ul>\n<li>SSL幫助加密你的網頁傳輸，防止資料外流</li>\n<li>讓瀏覽器信任你的網頁</li>\n<li>付費系統等等必須使用SSL</li>\n<li>現在都<strong>免費</strong>了，還在考慮甚麼…</li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"Let’s-Encrypt的限制\"><a href=\"#Let’s-Encrypt的限制\" class=\"headerlink\" title=\"Let’s Encrypt的限制\"></a>Let’s Encrypt的限制</h2><ul>\n<li>因為加密了所以速度比較慢，這是HTTPs的缺點</li>\n<li>90天要更新一次證書</li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"一﹒安裝certbot\"><a href=\"#一﹒安裝certbot\" class=\"headerlink\" title=\"一﹒安裝certbot\"></a>一﹒安裝certbot</h2><p>這裡就介紹常用的Ubuntu + Nginx的安裝方法，其實就只是根據官方供的<a href=\"https://certbot.eff.org/\" target=\"_blank\" rel=\"external\">certbot</a>的指示做，但還是簡單講一下吧 首先來安裝letsencrypt</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">sudo apt-get install letsencrypt\n</code></pre>\n<p>  然後就是生產證書，把以下的指令修改成你的<strong>網域</strong>和網頁的<strong>根目錄</strong>，假設你的網域是<code>example</code>，根目錄是<code>/var/www/example</code></p>\n<pre><code>letsencrypt certonly --webroot -w /var/www/example -d example.com -d www.example.com\n</code></pre><p>上面指令將會在<code>/etc/letsencrypt/live/example.com/</code>產生四個檔案</p>\n<ul>\n<li>cert.pem</li>\n<li>chain.pem</li>\n<li>fullchain.pem</li>\n<li>privkey.pem</li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"二﹒設定Nginx\"><a href=\"#二﹒設定Nginx\" class=\"headerlink\" title=\"二﹒設定Nginx\"></a>二﹒設定Nginx</h2><p>我們把本來使用的<code>port 80</code>換成<code>port 443</code>，然後加入<code>fullchain.pem</code>和<code>privkey.pem</code>兩張證書，就像這樣</p>\n<pre><code>server {\n    listen *:443 ssl http2;\n    listen [::]:443 ssl http2;\n\n    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n\n    root /var/www/example;\n\n    ...\n}\n</code></pre><p>然後我們可以選擇把所有http的請求自動轉到https</p>\n<pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    server_name example.com www.example.com;\n    return 301 https://$server_name$request_uri;\n}\n</code></pre><p>最後從新載入nginx的設定就大功告成了！</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>sudo systemctl reload nginx\n</code></pre><p>&nbsp;</p>\n<h2 id=\"自動更新證書\"><a href=\"#自動更新證書\" class=\"headerlink\" title=\"自動更新證書\"></a>自動更新證書</h2><p>由於Let’s Encrypt的限制，證書需要每90天更新一次，所以certbot很貼心地提供了一個更新的指令讓我們使用，而且也建議我們用<code>cron</code>或是<code>systemd</code>每天檢查兩次，我們不用擔心更新過多的問題，因為<strong>快到期之前</strong>即使運行了指令它也是<strong>不會更新</strong>的，所以我們可以每天的1AM和1PM各檢查更新一次，這樣就做到自動更新的效果了</p>\n<p>這裡我選擇用crontab</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>sudo crontab -e\n</code></pre><p>初次使用應該會出現以下畫面，個人習慣用nano，所以選2</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>no crontab for root - using an empty one\n\nSelect an editor.  To change later, run &#39;select-editor&#39;.\n  1. /bin/ed\n  2. /bin/nano        &lt;---- easiest\n  3. /usr/bin/vim.basic\n  4. /usr/bin/vim.tiny\n\nChoose 1-4 [2]:\n</code></pre><p>選擇以後會跳到編輯版面，在最下面輸入以下語句</p>\n<pre><code>10 1,13 * * * /usr/bin/letsencrypt renew &gt;&gt; /var/log/le-renew.log\n15 1,13 * * * /etc/init.d/nginx reload\n</code></pre><p>最後按<code>Ctrl + X</code>儲存後系統便會依據時間自動執行了！</p>\n","categories":[],"tags":[]},{"title":"棄坑從SPA回到Wordpress，最大的敵人是SEO？","url":"http://localhost:4000/2017/03/19/back-to-wordpress/","content":"<p>由最初決定建立這個網誌開始已經一個月了，作為一個開發者，當然想自己動手建立屬於自己風格的網頁，所以就決定用Wordpress做後端提供API，然後以熟悉的Angular1寫一個Single Page Application（SPA）​，因為WP的API很完善所以花不到兩天就把它寫出來了。可是當我放到Google Webmasters後發現<strong>SEO未如理想</strong>，而且Google只搜到我不想讓人看到的WP頁面，所以我又花了幾天時間把WP改成private連接埠，可是效果也不是很好，經過一些資料搜集後最後還是決定回到Wordpress了…<br>&nbsp;</p>\n<h2 id=\"為甚麼SPA的SEO這麼糟糕？\"><a href=\"#為甚麼SPA的SEO這麼糟糕？\" class=\"headerlink\" title=\"為甚麼SPA的SEO這麼糟糕？\"></a>為甚麼SPA的SEO這麼糟糕？</h2><p>現在很多SPA都是用client-side rendering的，意思就是在前端做運算，例如用JS產生一些HTML碼，所以當Google這些搜尋引擎嘗試讀取你的網頁它通常都讀不到JS生產出來的東西，而且文章的頁面也都是用JS產生出來的，如果不提供一個sitemap結果就像我這樣只能搜到首頁<br>&nbsp;</p>\n<h2 id=\"如果真的要用SPA怎麼辦？\"><a href=\"#如果真的要用SPA怎麼辦？\" class=\"headerlink\" title=\"如果真的要用SPA怎麼辦？\"></a>如果真的要用SPA怎麼辦？</h2><p>這是我部份的資料搜集，理​論上就是把你的網頁改為server rendering，其中一個方法在初次瀏覽的時候產生一個緩存，下次請求的時候便會直接回傳那個緩存了的網頁，讓搜尋引擎可以立刻讀到你的網頁內容，做法就是自行設定一個rendering server例如<a href=\"http://phantomjs.org/\" target=\"_blank\" rel=\"external\">phantomJS</a>，但這方法有點麻煩，而且我的VM也不太夠資源做，所以再試了其他人提供的服務，例如<a href=\"https://prerender.io/\" target=\"_blank\" rel=\"external\">prerender.io</a>、<a href=\"https://www.seo4ajax.com/\" target=\"_blank\" rel=\"external\">seo4ajax</a>等等，前者跟我的網頁好像無緣，試很久還是不太行，後者就是太貴了，​而且我發現很多方法都是用<a href=\"https://developers.google.com/webmasters/ajax-crawling/docs/specification#bidirectional-between--url-to-_escaped_fragment_-url\" target=\"_blank\" rel=\"external\">_escaped<em>fragment</em></a>告訴Google讀取的，但是根據Google <a href=\"https://webmasters.googleblog.com/2015/10/deprecating-our-ajax-crawling-scheme.html\" target=\"_blank\" rel=\"external\">2015年末的報告</a>好像不建議這方法，所以最後還是打消了這念頭，果斷放棄SPA…<br>&nbsp;</p>\n<h2 id=\"結論\"><a href=\"#結論\" class=\"headerlink\" title=\"結論\"></a>結論</h2><p>最後就做一個總結，雖然還沒有看到轉成WP的效果，但是這些應該是錯不了的</p>\n<ul>\n<li>SPA的SEO暫時還是比較差</li>\n<li>用前端JS產生HTML很大程上影響到SEO</li>\n<li>SPA需要用緩存解決SEO問題</li>\n<li>還是wordpress比較適合初學者</li>\n</ul>\n","categories":[],"tags":[]},{"title":"輕鬆學習RESTful API，人見人愛的簡約設計！","url":"http://localhost:4000/2017/03/19/restful-api/","content":"<p>REST是一種風格，RESTful API則是符合REST風格的API，正所謂<strong>less is more</strong>，REST完美地表這個精神，但是跟隨這風格一點也不簡單，要成為人見人愛的REST開發者，就應該更小心不要犯常見的錯誤<br>&nbsp;</p>\n<h2 id=\"一﹒５個常用Method\"><a href=\"#一﹒５個常用Method\" class=\"headerlink\" title=\"一﹒５個常用Method\"></a>一﹒５個常用Method</h2><p>RESTful API常用的method有五種</p>\n<ul>\n<li>GET - 取得資料</li>\n<li>POST - 寫入或增加資料</li>\n<li>PUT - 更新整個資料</li>\n<li>PATCH - 更新資料裡面的一部分</li>\n<li>DELETE - 刪除資料</li>\n</ul>\n<p>&nbsp;</p>\n<h2 id=\"二﹒常犯錯誤１：不要用錯Method！\"><a href=\"#二﹒常犯錯誤１：不要用錯Method！\" class=\"headerlink\" title=\"二﹒常犯錯誤１：不要用錯Method！\"></a>二﹒常犯錯誤１：不要用錯Method！</h2><p>上面指出的５個method已經是最基本的了，不要再讓自己局限於GET、POST兩種，要緊記API是<strong>讓別人看</strong>的，RESTful的原意是<strong>stateless</strong>，是<strong>不需要有協議</strong>也能很容易知道如果使用，這方面必須用對method才能達到這個目的，以下列出一個簡單的CRUD例子</p>\n<p><strong>取得生果清單</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>GET /fruits\n</code></pre><p><strong>取得生果清單裡面的蘋果</strong>，假設蘋果的<code>id</code>是1</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>GET /fruits/1\n</code></pre><p><strong>增加橘子到生果清單</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>POST /fruits\n{\n  id: 2,\n  name: &quot;Orange&quot;,\n  description: &quot;This is an orange&quot;\n}\n</code></pre><p><strong>更新橘子的description</strong>，用<code>PATCH</code>的意義就是只改部份，而不會進行覆蓋，以下例子就是只改<code>description</code>而不改<code>name</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>PATCH /fruits/2\n{\n  description: &quot;This is a juicy orange&quot;\n}\n</code></pre><p>  <strong>把橘子的record變成梨子</strong>，因為我們用<code>PUT</code>，所以這裡連原有的<code>description</code>也會被覆蓋掉了</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>PUT /fruits/2\n{\n  name: &quot;Pear&quot;\n}\n</code></pre><p><strong>刪除蘋果</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>DELETE /fruits/1\n</code></pre><p>&nbsp;</p>\n<h2 id=\"三﹒常犯錯誤２：不要胡亂命名\"><a href=\"#三﹒常犯錯誤２：不要胡亂命名\" class=\"headerlink\" title=\"三﹒常犯錯誤２：不要胡亂命名\"></a>三﹒常犯錯誤２：不要胡亂命名</h2><p>原因同上，RESTful API的URL不應該出現動詞，所以<strong>不要這樣寫</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>GET /getFruits\n</code></pre><p>另外不是unique的話請緊記用<strong>複數</strong>命名，所以也<strong>不要這樣寫</strong></p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>GET /frust\n</code></pre><p>所以應該寫成這樣才正確</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>GET /fruits\n</code></pre><p>&nbsp;</p>\n<h2 id=\"四﹒利用Sub-resource表示關聯性\"><a href=\"#四﹒利用Sub-resource表示關聯性\" class=\"headerlink\" title=\"四﹒利用Sub resource表示關聯性\"></a>四﹒利用Sub resource表示關聯性</h2><p>這個設計可以令使用者逐層探索你的API，以下就是一個常見的例子，首先我們取得<code>product</code>的清單</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>GET /products\n</code></pre><pre><code>[\n  {\n    id: 1,\n    name: &quot;fruits&quot;\n  },\n  {\n    id: 2,\n    name: &quot;drinks&quot;\n  }\n]\n</code></pre><p>  由於是一個複數的請求，所以我們會取得一個<code>Array</code>，而清單入面不會有太多資料，我們只知道有<code>fruits</code>和<code>drinks</code>可以選擇，我們就選擇<code>fruits</code>看看</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>GET /products/1\n</code></pre><pre><code>{\n  id: 1,\n  name: &quot;fruits&quot;,\n  items: [\n    {\n      id: 1,\n      name: &quot;apple&quot;\n    },\n    {\n      id: 2,\n      name: &quot;orange&quot;\n    }\n  ]\n}\n</code></pre><p>在<code>fruits</code>裡面我們想看橘子的資料，所以我們這樣請求</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>GET /products/1/items/2\n</code></pre><pre><code>{\n  id: 1,\n  name: &quot;orange&quot;,\n  description: &quot;This is an orange&quot;\n}\n</code></pre><p>到這樣有沒有發現哪裡怪怪的？沒有發現嗎？請繼續往下看吧！<br>&nbsp;</p>\n<h2 id=\"五﹒使用HATEOAS\"><a href=\"#五﹒使用HATEOAS\" class=\"headerlink\" title=\"五﹒使用HATEOAS\"></a>五﹒使用HATEOAS</h2><p><a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"external\">HATEOAS</a> 是其中一種RESTful API的條件，之前不是提到REST是一種<code>stateless</code>的設計嗎？那麼上面的例子裡由選擇生果的時候開始便是<strong>用猜</strong>的方式去取得<code>sub resource</code>的，這不是一個很好的練習，所以我們要用HATEOAS，我們可以加插<code>link</code>，讓使用者知道如何查詢下一層的資料，以下是改善後的例子</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>GET /products\n</code></pre><pre><code>[\n  {\n    id: 1,\n    name: &quot;fruits&quot;,\n    _links: {\n      self: {\n        href: &quot;/products/1&quot;\n      }\n    }\n  }\n]\n</code></pre><p>&nbsp;</p>\n<h2 id=\"六﹒給你的API一個版本\"><a href=\"#六﹒給你的API一個版本\" class=\"headerlink\" title=\"六﹒給你的API一個版本\"></a>六﹒給你的API一個版本</h2><p>最後來談一下版本的問題，雖然跟REST沒太大關係，但加版本是一個不錯的練習，因為將來即使一點小改動都可能會影響到現有的用家，所以最好的情況就是開始的時候便加入版本例如叫<code>v1</code>，以後有不能向後兼容的情況便增一個<code>v2</code>的API</p>\n<pre><code>GET /api/v1/products\n</code></pre><p>&nbsp;</p>\n<h2 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h2><p>說到底REST都只是一種風格，就算不跟隨也不會影響API的功能，如果不喜歡也沒關係，但有時候我們不一定是開發的那方，也會有使用的時候，經常認識一下一些趨勢相信必定是有利無害的！</p>\n","categories":[],"tags":[]},{"title":"管理網頁緩存原來可以很簡單！","url":"http://localhost:4000/2017/03/19/browser-cache/","content":"<p>瀏覽器緩存是<a href=\"https://en.wikipedia.org/wiki/Web_cache\" target=\"_blank\" rel=\"external\">web cache</a>的一種，主要作用就是緩存靜態的檔案，降低下次請求時的流量，所以這個設計對於數據傅輸速度不快的移動裝置用家非常有用，可是緩存處理不當會另理應需要更新的檔案無法更新，降低了用家的體驗，以下就來看看解決的方法！<br>&nbsp;</p>\n<h2 id=\"一﹒手動清除緩存\"><a href=\"#一﹒手動清除緩存\" class=\"headerlink\" title=\"一﹒手動清除緩存\"></a>一﹒手動清除緩存</h2><p>這方法只會清除本地緩存，是給開發者的方法，以Chrome做例子，最簡單的做法就是按<code>F12</code>開啟console，在<code>更新按鈕</code>上按<code>右鍵</code>，便會出現<code>Empty Cache and Hard Reload</code>的選項，其他瀏覽器可以參考<a href=\"http://www.refreshyourcache.com/en/home/\" target=\"_blank\" rel=\"external\">這篇文章</a><br><img src=\"https://i0.wp.com/3rider.com/wp-content/uploads/2017/02/chrome-cache.png\" alt=\"\"><br>&nbsp;</p>\n<h2 id=\"二﹒伺服器設定\"><a href=\"#二﹒伺服器設定\" class=\"headerlink\" title=\"二﹒伺服器設定\"></a>二﹒伺服器設定</h2><p>我們可以在伺服器設定<strong>永遠不緩存</strong>，事先聲明，這<strong>不是一個好方法</strong>，緩存有很多好處，所以<strong>盡量不要用</strong>這方法吧！以下的例子都是參考<a href=\"http://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers\" target=\"_blank\" rel=\"external\">這篇QA</a>的，我們只要將伺服器的HTTP header設定成這樣，下次就不會有緩存了…</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">Cache-Control: no-cache, no-store, must-revalidate\nPragma: no-cache\nExpires: 0\n</code></pre>\n<p>以下是一些常用的設定</p>\n<ol>\n<li>Node.js<br><p class=\"code-caption\" data-lang=\"js\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><pre><code class=\"js\">res.header(&#39;Cache-Control&#39;, &#39;no-cache, private, no-store, must-revalidate, max-stale=0, post-check=0, pre-check=0&#39;);\n</code></pre>\n</li>\n<li>PHP<br><p class=\"code-caption\" data-lang=\"php\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><pre><code class=\"php\">header(&quot;Cache-Control: no-cache, no-store, must-revalidate&quot;); // HTTP 1.1.\nheader(&quot;Pragma: no-cache&quot;); // HTTP 1.0.\nheader(&quot;Expires: 0&quot;); // Proxies.\n</code></pre>\n</li>\n<li>Nginx<br><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><pre><code class=\"bash\">add_header Cache-Control no-cache;\n</code></pre>\n</li>\n<li>Apache<br><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><pre><code class=\"bash\">Header set Cache-Control &quot;no-cache, no-store, must-revalidate&quot;\nHeader set Pragma &quot;no-cache&quot;\nHeader set Expires 0\n</code></pre>\n</li>\n</ol>\n<p>&nbsp;</p>\n<h2 id=\"三﹒利用cache-busting\"><a href=\"#三﹒利用cache-busting\" class=\"headerlink\" title=\"三﹒利用cache busting\"></a>三﹒利用cache busting</h2><p>另外一個方法是<a href=\"https://css-tricks.com/strategies-for-cache-busting-css/\" target=\"_blank\" rel=\"external\">cache busting</a> ，也是比較好的做法，特別適用於vendor.js、app.js這類經常會改動原碼，但不會改變名稱的檔案，透過增加一個額外的<code>query字串</code>，讓瀏覽器判斷這個檔案需要更新，這樣就可以保留緩存功能又能防止誤判的情況</p>\n<p></p><p class=\"code-caption\" data-lang=\"html\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"html\">&lt;script src=&quot;app.js?v=1&quot;&gt;&lt;/script&gt;\n</code></pre>\n<p>&nbsp;<br>除了加版本，我們還可以增加一個<code>timestamp字串</code>，效果基本上等於沒有緩存，但這個方法還是比修改伺服器的設定好，因為我們可以只控制個別不想做緩存檔案，而不是全部不使用</p>\n<p></p><p class=\"code-caption\" data-lang=\"html\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"html\">&lt;script&gt;\n  document.write(&quot;&lt;script src=\\&quot;app.js?v=&quot; + new Date().getTime() + &quot;\\&quot;&gt;&lt;\\/script&gt;&quot;);\n&lt;/script&gt;\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"後記\"><a href=\"#後記\" class=\"headerlink\" title=\"後記\"></a>後記</h2><p>有時候很多這些細微的東西很容易會被忽略掉，遇到的時候又用不正規的方法處理掉，花點時間研究一下，其實很容易就可以解決了！</p>\n","categories":[],"tags":[]},{"title":"十分鐘試玩Elasticsearch，最快NoSQL db之一！","url":"http://localhost:4000/2017/03/19/install-es/","content":"<p>因為工作的關係很多時候會接觸到<strong>資料分析</strong>的部份，所以需要一個靈活而快速的資料庫協助，而Elasticsearch （ES）是暫時測試過最快的NoSQL之一，雖然它不適合作主數據庫（讀寫會有誤差），但作為索引引擎它可說是一流的！<br>&nbsp;</p>\n<h2 id=\"一﹒安裝Elasticsearch\"><a href=\"#一﹒安裝Elasticsearch\" class=\"headerlink\" title=\"一﹒安裝Elasticsearch\"></a>一﹒安裝Elasticsearch</h2><p>因為這次純屬試玩，所以也不做多餘的設定了，直接用官方提供的免安裝zip體驗一下，首先到<a href=\"https://www.elastic.co/downloads/elasticsearch\" target=\"_blank\" rel=\"external\">官方下載</a>目前最新的5.2版本壓縮檔，下載好了以後解壓，然後用它提供的binary啟動</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">cd elasticsearch-5.2.0\n./bin/elasticsearch\n</code></pre>\n<p>啟動後可以在<a href=\"http://localhost:9200\">http://localhost:9200</a>查看資料庫的狀態</p>\n<p></p><p class=\"code-caption\" data-lang=\"json\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"json\">{\n  &quot;name&quot; : &quot;ddBd3a_&quot;,\n  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,\n  &quot;cluster_uuid&quot; : &quot;megP9_F-S06WuK6hJAVrdw&quot;,\n  &quot;version&quot; : {\n    &quot;number&quot; : &quot;5.2.0&quot;,\n    &quot;build_hash&quot; : &quot;24e05b9&quot;,\n    &quot;build_date&quot; : &quot;2017-01-24T19:52:35.800Z&quot;,\n    &quot;build_snapshot&quot; : false,\n    &quot;lucene_version&quot; : &quot;6.4.0&quot;\n  },\n  &quot;tagline&quot; : &quot;You Know, for Search&quot;\n}\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"二﹒安裝Sense插件\"><a href=\"#二﹒安裝Sense插件\" class=\"headerlink\" title=\"二﹒安裝Sense插件\"></a>二﹒安裝Sense插件</h2><p>需然ES可以用HTTP請求執行指令，例如<code>CURL</code>，但還是有介面比較方便，所以我們可以安裝Chrome的<a href=\"https://chrome.google.com/webstore/detail/sense-beta/lhjgkmllcaadmopgmanpapmpjgmfcfig\" target=\"_blank\" rel=\"external\">Sense</a>插件執行指令<br><img src=\"https://3rider.com/wp-content/uploads/2017/02/es-query.png\" alt=\"\"><br>&nbsp;</p>\n<h2 id=\"三﹒了解更多Elasticsearch\"><a href=\"#三﹒了解更多Elasticsearch\" class=\"headerlink\" title=\"三﹒了解更多Elasticsearch\"></a>三﹒了解更多Elasticsearch</h2><p>NoSQL就是非關係數據庫，很多時候都比較靈活，例如不需要建立table、也不需要再畫麻煩的ERD了！但當然也可以設定一些架構（Schema）限制資料輸入，但這篇就不說明這些了，想了解更多可以到<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html\" target=\"_blank\" rel=\"external\">這裡</a>學習學習，另外關於它<code>index</code>和<code>type</code>的概念可以到<a href=\"https://www.elastic.co/blog/index-vs-type\" target=\"_blank\" rel=\"external\">官方blog</a>了解<br>&nbsp;</p>\n<h2 id=\"四﹒核心指令\"><a href=\"#四﹒核心指令\" class=\"headerlink\" title=\"四﹒核心指令\"></a>四﹒核心指令</h2><p>核心指令分為４種，就是常見的CRUD</p>\n<ul>\n<li>GET：查詢</li>\n<li>POST：寫入</li>\n<li>PUT：更新或寫入（<code>upsert</code>功能，當沒有可更新的條件便寫入）</li>\n<li>DELETE：刪除</li>\n</ul>\n<p>而它用的是RESTful風格的請求，以下是一些例子，當中有使用到<code>search</code>的地方就如SQL的<code>where</code>一樣，更多用法可以參考<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html\" target=\"_blank\" rel=\"external\">官方的教學</a></p>\n<p></p><p class=\"code-caption\" data-lang=\"json\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"json\">PUT twitter/tweet/1\n{\n    &quot;user&quot; : &quot;peter&quot;,\n    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,\n    &quot;message&quot; : &quot;trying out Elasticsearch update&quot;\n}\n\nPOST twitter/tweet\n{\n    &quot;user&quot; : &quot;john&quot;,\n    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,\n    &quot;message&quot; : &quot;trying out Elasticsearch&quot;\n}\n\nGET twitter/tweet/1\n\nGET twitter/tweet/_search\n\nDELETE twitter/tweet/1\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"五﹒基本Searching\"><a href=\"#五﹒基本Searching\" class=\"headerlink\" title=\"五﹒基本Searching\"></a>五﹒基本Searching</h2><p>以下的例子我們建立了２個<code>user</code>，分別是<code>peter</code>和<code>john</code>，然後用了３種搜尋方法</p>\n<ul>\n<li>Exists：如果搜尋的<code>field</code>存在</li>\n<li>Term：搜尋的值等同於數據記錄的值</li>\n<li>Range：數據記錄的值在兩個搜尋值之間</li>\n</ul>\n<p>&nbsp;<br>除此之外還有很多用法，可以到<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html\" target=\"_blank\" rel=\"external\">這裡</a>查看詳細資料，以下例子先建立了兩個<code>user</code>，然後再用上面提到的３種方法搜尋</p>\n<p></p><p class=\"code-caption\" data-lang=\"json\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"json\">PUT twitter/tweet/1\n{\n    &quot;user&quot; : &quot;peter&quot;,\n    &quot;age&quot;: 10\n}\n\nPUT twitter/tweet/2\n{\n    &quot;user&quot; : &quot;john&quot;,\n    &quot;age&quot;: 20,\n    &quot;gender&quot;: &quot;Male&quot;\n}\n\nGET twitter/tweet/_search\n{\n    &quot;query&quot;: {\n        &quot;exists&quot;: {\n            &quot;field&quot;: &quot;gender&quot;\n        }\n    }\n}\n\nGET twitter/tweet/_search\n{\n    &quot;query&quot;: {\n        &quot;term&quot;: {\n           &quot;user&quot;: {\n              &quot;value&quot;: &quot;peter&quot;\n           }\n        }\n    }\n}\n\nGET twitter/tweet/_search\n{\n    &quot;query&quot;: {\n        &quot;range&quot;: {\n           &quot;age&quot;: {\n              &quot;from&quot;: 19,\n              &quot;to&quot;: 30\n           }\n        }\n    }\n}\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"六﹒Aggregation\"><a href=\"#六﹒Aggregation\" class=\"headerlink\" title=\"六﹒Aggregation\"></a>六﹒Aggregation</h2><p>ES在<code>Aggregation</code>方面最特出，因為它在速度上比其他資料庫快很多，而這功能主要就是幫我們做計算，搜尋並合併（Map-Reduce），縮減成一些有意義的數據，所以對於分析方面是非常有利的，我們就以上例子試用<code>Aggregation</code>計算<code>總年齡</code>和<code>平均年齡</code></p>\n<pre><code>GET twitter/tweet/_search\n{\n    &quot;size&quot;: 0, \n    &quot;aggs&quot;: {\n        &quot;sumAge&quot;: {\n            &quot;sum&quot;: {\n                &quot;field&quot;: &quot;age&quot;   \n            }\n        }\n    }\n}\n\nGET twitter/tweet/_search\n{\n    &quot;size&quot;: 0, \n    &quot;aggs&quot;: {\n        &quot;avgAge&quot;: {\n            &quot;sum&quot;: {\n                &quot;field&quot;: &quot;age&quot;   \n            }\n        }\n    }\n}\n</code></pre><p>&nbsp;</p>\n<h2 id=\"七﹒後記\"><a href=\"#七﹒後記\" class=\"headerlink\" title=\"七﹒後記\"></a>七﹒後記</h2><p>Elasticsearch還有很多好玩的功能待大家發掘，以後有機會再補上一些進階的用法讓各位參考！</p>\n","categories":[],"tags":[]},{"title":"Gulp的簡易使用教學","url":"http://localhost:4000/2017/03/19/gulp-example/","content":"<p>Gulp這神器完全是為了我們這懶人而設的，用了它之後開發速度快了一倍以上！而且它精簡的結構是其它工具（Grunt、Webpack…）無法與之相比的，以下為大家介紹常用的功能<br>&nbsp;</p>\n<h2 id=\"一﹒安裝Gulp\"><a href=\"#一﹒安裝Gulp\" class=\"headerlink\" title=\"一﹒安裝Gulp\"></a>一﹒安裝Gulp</h2><p>Gulp需要Node.js才能運作，沒有Node可以看這篇<a href=\"/posts/26\">Node安裝教學</a>，然後再用NPM安裝Gulp</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">npm install gulp -g\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"二﹒gulpfile-js設定檔\"><a href=\"#二﹒gulpfile-js設定檔\" class=\"headerlink\" title=\"二﹒gulpfile.js設定檔\"></a>二﹒gulpfile.js設定檔</h2><p>Gulp會自動讀取路徑內的<code>gulpfile.{ext}</code>設定檔，而這個檔案需要自行建立，我們先建立<code>gulpfile.js</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">touch gulpfile.js\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"三﹒使用Gulp指令\"><a href=\"#三﹒使用Gulp指令\" class=\"headerlink\" title=\"三﹒使用Gulp指令\"></a>三﹒使用Gulp指令</h2><p>之前我們在全域安裝了gulp，所以我們可以在<code>Terminal</code>內用<code>gulp</code>的指令，指令是根據<code>gulpfile.js</code>內的<code>task</code>（任務）而定的，所以我們可以自行加入新指令，很方便吧？默認的指令是<code>default</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"js\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"js\">var gulp = require(&#39;gulp&#39;);\n\ngulp.task(&#39;default&#39;, function () {\n  console.log(&#39;Hello!&#39;);\n});\n</code></pre>\n<p>現在我們還未可以執行指令，我們需要在路徑內再次安裝<code>gulp</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">npm install gulp\n</code></pre>\n<p>到這裡終於可以執行了！輸入<code>gulp</code>運行默認的<code>task</code></p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">gulp\n</code></pre>\n<p>輸出大概是這樣</p>\n<p></p><p class=\"code-caption\" data-lang=\"\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code>[13:29:26] Using gulpfile ~/projects/gulp-example/gulpfile.js\n[13:29:26] Starting &#39;default&#39;...\nHello!\n[13:29:26] Finished &#39;default&#39; after 104 μs\n</code></pre><p>&nbsp;</p>\n<h2 id=\"四﹒自定指令名稱\"><a href=\"#四﹒自定指令名稱\" class=\"headerlink\" title=\"四﹒自定指令名稱\"></a>四﹒自定指令名稱</h2><p>當然我們可以自定指令的名稱，除了<code>default</code>以外的<code>task</code>都會以<code>gulp {task}</code>的指令運作，就以上的例子我們改成這裡</p>\n<p></p><p class=\"code-caption\" data-lang=\"js\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"js\">var gulp = require(&#39;gulp&#39;);\n\ngulp.task(&#39;greeting&#39;, function () {\n  console.log(&#39;Hello!&#39;);\n});\n</code></pre>\n<p>我們把<code>task</code>改成<code>greeting</code>，換言之指令就會變成這樣</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">gulp greeting\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"五﹒三個主要函数\"><a href=\"#五﹒三個主要函数\" class=\"headerlink\" title=\"五﹒三個主要函数\"></a>五﹒三個主要函数</h2><ol>\n<li>Source<br>設定來源的<code>globs</code>，可以用<code>Array</code>包含多個<code>globs</code>，亦可以用<code>!</code>排除<br><p class=\"code-caption\" data-lang=\"js\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><pre><code class=\"js\">gulp.src(&#39;index.js&#39;);\ngulp.src(&#39;**/*.js&#39;);\ngulp.src([&#39;**/*.js&#39;, &#39;!index.js&#39;])\n</code></pre>\n&nbsp;</li>\n<li>Pipeline<br>包含了主要的工作，例如編譯scss然後minify，這些都需要額外模組執行<br><p class=\"code-caption\" data-lang=\"js\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><pre><code class=\"js\">gulp.src(&#39;scss/*.scss&#39;)\n .pipe(scss())\n .pipe(minify());\n</code></pre>\n&nbsp;</li>\n<li>Destination<br>設定輸出位置<br><p class=\"code-caption\" data-lang=\"js\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><pre><code class=\"js\">gulp.src(&#39;scss/*.scss&#39;)\n .pipe(scss())\n .pipe(minify())\n .pipe(gulp.dest(&#39;build/css&#39;));\n</code></pre>\n&nbsp;</li>\n</ol>\n<h2 id=\"六﹒常用的Gulp插件\"><a href=\"#六﹒常用的Gulp插件\" class=\"headerlink\" title=\"六﹒常用的Gulp插件\"></a>六﹒常用的Gulp插件</h2><p>Gulp的插件真的非常多沒辦法逐一介紹，以下列出一些我常用的插件讓大家參考</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-watch\" target=\"_blank\" rel=\"external\">gulp-watch</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-plumber\" target=\"_blank\" rel=\"external\">gulp-plumber</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-connect\" target=\"_blank\" rel=\"external\">gulp-connect</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-livereload\" target=\"_blank\" rel=\"external\">gulp-livereload</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-sass\" target=\"_blank\" rel=\"external\">gulp-sass</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-sourcemaps\" target=\"_blank\" rel=\"external\">gulp-sourcemaps</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-uglify\" target=\"_blank\" rel=\"external\">gulp-uglify</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-clean-css\" target=\"_blank\" rel=\"external\">gulp-clean-css</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-concat\" target=\"_blank\" rel=\"external\">gulp-concat</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-concat-css\" target=\"_blank\" rel=\"external\">gulp-concat-css</a></li>\n</ul>\n","categories":[],"tags":[]},{"title":"Node.js簡易安裝教學","url":"http://localhost:4000/2017/03/18/nodejs-helloworld/","content":"<p>Node.js已經流行一段時間了，越來越多工作要求懂得Node.js，還未學會就趕快安裝一個追上潮流吧！<br>&nbsp;</p>\n<h2 id=\"一﹒安裝NVM\"><a href=\"#一﹒安裝NVM\" class=\"headerlink\" title=\"一﹒安裝NVM\"></a>一﹒安裝NVM</h2><p>使用<a href=\"https://github.com/creationix/nvm\" target=\"_blank\" rel=\"external\">NVM（Node Version Manager）</a>其中一個好處就是容易安裝，官方的實在太麻煩了…另一個好處是可以<strong>隨時切換版本</strong>，可能現在你還不明白，等到你長大後自然就會懂了（謎の聲：你是我老爸嗎？）</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash`\n\nexport NVM_DIR=&quot;$HOME/.nvm&quot;\n[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"二﹒安裝Node-js\"><a href=\"#二﹒安裝Node-js\" class=\"headerlink\" title=\"二﹒安裝Node.js\"></a>二﹒安裝Node.js</h2><p>然後我們就可以用NVM安裝Node.js了，我們可以用<code>ls-remote</code>查詢可以安裝的版本，沒特別要求就用LTS（Long term support）版本吧</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">nvm ls-remote\nnvm install 6\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"三﹒編寫第一個Hello-World程式\"><a href=\"#三﹒編寫第一個Hello-World程式\" class=\"headerlink\" title=\"三﹒編寫第一個Hello World程式\"></a>三﹒編寫第一個Hello World程式</h2><p>學一種語言最快的方法就是Hello World了，隨意到一個地方建立<code>index.js</code>，裡面輸入</p>\n<p></p><p class=\"code-caption\" data-lang=\"js\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"js\">console.log(&#39;hello world!&#39;)\n</code></pre>\n<p>最後開啟你的Terminal，執行node index.js看結果吧！</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">node index.js\n</code></pre>\n<p>&nbsp;</p>\n<h2 id=\"四﹒解決Node-JS-Error-ENOSPC的問題\"><a href=\"#四﹒解決Node-JS-Error-ENOSPC的問題\" class=\"headerlink\" title=\"四﹒解決Node.JS Error: ENOSPC的問題\"></a>四﹒解決Node.JS Error: ENOSPC的問題</h2><p>這是初次裝Node.js很常見的問題，在Terminal執行以下指令就可以解決了</p>\n<p></p><p class=\"code-caption\" data-lang=\"bash\" data-line_number=\"frontend\" data-trim_indent=\"backend\" data-label_position=\"outer\" data-labels_left=\"Code\" data-labels_right=\":\" data-labels_copy=\"Copy Code\"><span class=\"code-caption-label\"></span></p><p></p>\n<pre><code class=\"bash\">echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p\n</code></pre>\n","categories":[],"tags":["Node.js"]}]