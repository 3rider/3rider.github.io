<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[CSS框架篇：如何用Node.js寫一個網頁應用？]]></title>
      <url>https://3rider.com/posts/CSS%E6%A1%86%E6%9E%B6%E7%AF%87%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8Node.js%E5%AF%AB%E4%B8%80%E5%80%8B%E7%B6%B2%E9%A0%81%E6%87%89%E7%94%A8%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>相信介面（UI）設計是很多網頁開發者的弱點，更不用說用戶體驗了（UX）！在這個移動設備發達的年代大家都在說mobile-first，可想而之對於一個連CSS也只是略懂皮毛的新手到底是多大的難關，幸好！正因為這樣，出現了很多CSS框架（framework），讓我們不用幾乎不用碰CSS也能夠拼出一個不錯的介面</p>
<h2 id="Bootstrap框架"><a href="#Bootstrap框架" class="headerlink" title="Bootstrap框架"></a>Bootstrap框架</h2><img src="/posts/CSS框架篇：如何用Node.js寫一個網頁應用？/bootstrap.jpg" alt="bootstrap.jpg" title="">
<p>Bootstrap算是框架界的老字號了，網頁開發者很介意框架的容量，臃腫的框架會影響用戶體驗，但太輕量的框架幫助又不大，Bootstrap在這方面比較平衡，所以很多開發者選擇使用它。當然這也有好壞處，好處就是社群支援比較多，有很多snippet甚至template讓你免費使用，能幫你快速完成一個網頁，而壞處就是用框架可能會導至跟別人的網站很相似，失去個人風格。不過這也不是這篇教學的重點，而且對新手來說能跟別人的網頁看起來差不多好像也不壞吧？</p>
<h2 id="自行託管vs雲端"><a href="#自行託管vs雲端" class="headerlink" title="自行託管vs雲端"></a>自行託管vs雲端</h2><p>使用一個客戶端模組普遍有兩種方法，第一種是self-hosted（自行託管），另一種是cloud hosted（雲端託管）。前者很容易理解，就是模組架下載到主機再使用；而後者通常會搭配<a href="https://en.wikipedia.org/wiki/Content_delivery_network" target="_blank" rel="external">CDN（Content delivery network）</a>技術，通過這技術會自動選擇最接近客戶端的緩存伺器服，讓客戶端能更快讀取檔案。</p>
<h6 id="選擇哪一個？"><a href="#選擇哪一個？" class="headerlink" title="選擇哪一個？"></a>選擇哪一個？</h6><p>這個很視乎檔案的類型和用戶對象，用CDN可以減少網站的負擔，假如你的網站是全球性的，還可以提升平均讀取速度，增加可用性（availability），但依賴別人的服務需要考慮它的可靠性（Reliability），也要評估服務商的可信性。而自託雖然會吃伺服器的流量，但相對比較可靠，至少能連上網站道理上就能夠連上模組的檔案，所以在開發階段建議還是使用自託形式，免去不必要的等待時間，時間是很保貴的！</p>
<h2 id="安裝Bower"><a href="#安裝Bower" class="headerlink" title="安裝Bower"></a>安裝Bower</h2><img src="/posts/CSS框架篇：如何用Node.js寫一個網頁應用？/bower.png" alt="bower.png" title="">
<p>上一篇就提到npm這強大的模組管理系統，而另一個就叫bower，bower這東西其實快要被npm取代了，但它還有自己的好處，bower的原意是管理客戶端的模組，而npm則是Node的比較多，所以npm有時候會依賴Node的模組，如果不進行特別處理便無法在網頁上運行，而bower不會出現這樣的情況，那麼我們就一切從簡，用bower！</p>
<h6 id="bower安裝指令"><a href="#bower安裝指令" class="headerlink" title="bower安裝指令"></a>bower安裝指令</h6><p>我們用以下指令安裝bower，<code>-g</code>是global的意思，安裝好了以後我們就可以直接在terminal使用這指令</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>npm install bower -g
</code></pre><h2 id="下載Starter-project"><a href="#下載Starter-project" class="headerlink" title="下載Starter project"></a>下載Starter project</h2><p>這個starter project跟上一篇的原碼是一樣的，我們可以用git clone或是在<a href="https://github.com/3rider/node-tutorial-bootstrap-starter" target="_blank" rel="external">這裡下載</a>並解壓到<code>~/projects</code></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>cd ~/projects
git clone https://github.com/3rider/node-tutorial-bootstrap-starter.git
</code></pre><h6 id="了解npm模組"><a href="#了解npm模組" class="headerlink" title="了解npm模組"></a>了解npm模組</h6><p>如果你還記得上一篇我做提到<code>npm install --save</code>，這裡就用到這儲存模組資訊的好處，首先我們來看看目前的結構</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>node-tutorial-bootstrap-starter/
├── static/
│   └── index.html
├── package.json
└── server.json
</code></pre><p>你會發現這裡還沒有<code>node_modules</code>，為甚麼呢？我們在做團隊開發的時候經常要同步原碼，在同步的過程我們應該盡量減少需要同步的檔案，而這些固定不會被修改的模組檔案就是其中之一，所以我也沒有把這些檔案放到git。而關鍵就是package.json內儲存了的資訊，當中<code>dependencies</code>就表示這個項目依賴以下模組，而這次我們依賴express 4.15.3以上的版本</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>{
  ...
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;^4.15.3&quot;
  }
}
</code></pre><p>接下來就方便了，我們只需要執行<code>npm install</code>就可以把需要的模組自己下載到項目內</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>cd node-tutorial-bootstrap-starter
npm install
</code></pre><h2 id="初始化bower"><a href="#初始化bower" class="headerlink" title="初始化bower"></a>初始化bower</h2><p>做法跟npm一樣，bower會產生另外一個叫<code>bower.json</code>的案檔，它的用途跟npm大同小異</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>bower init
</code></pre><h2 id="安裝Bootstrap"><a href="#安裝Bootstrap" class="headerlink" title="安裝Bootstrap"></a>安裝Bootstrap</h2><p>有了bower以後，安裝bootstrap就很簡單了，首先我們用bower下載bootstrap</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>bower install bootstrap --save
</code></pre><p>跟npm一樣，bower會產生一個名叫<code>bower_components</code>的資料夾儲存模組，新安裝的bootstrap也在裡面，由於bootstrap依賴jquery，所以jquery也會自動安裝到項目內，現在的目錄大概像這樣</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>node-tutorial-bootstrap-starter/
├── bower_components/
│   ├── bootstrap/
│   └── jquery/
├── node_modules/
├── static/
│   └── index.html
├── bower.json
├── package.json
└── server.json
</code></pre><h6 id="加入bootstrap"><a href="#加入bootstrap" class="headerlink" title="加入bootstrap"></a>加入bootstrap</h6><p>接著我們就要把它們加到<code>index.html</code>內</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;

    &lt;!-- Vendor Stylesheet --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;bower_components/bootstrap/dist/css/bootstrap.min.css&quot;&gt;

    &lt;!-- Vendor JS --&gt;
    &lt;script src=&quot;bower_components/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;bower_components/bootstrap/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;

  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;
      &lt;h1&gt;嗨！世界！&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h6 id="使用bootstrap"><a href="#使用bootstrap" class="headerlink" title="使用bootstrap"></a>使用bootstrap</h6><p>使用bootstrap的時候我們只要插入相應的<code>class</code>便能插入它的樣式，例如我們想使用bootstrap風格的按鍵</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;

    &lt;!-- Vendor Stylesheet --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;bower_components/bootstrap/dist/css/bootstrap.min.css&quot;&gt;

    &lt;!-- Vendor JS --&gt;
    &lt;script src=&quot;bower_components/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;bower_components/bootstrap/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;

  &lt;/head&gt;
  &lt;body&gt;
    &lt;div&gt;
      &lt;h1&gt;嗨！世界！&lt;/h1&gt;
      &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;默認風格&lt;/button&gt;
      &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;主要風格&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>啟動伺服器，如果你還沒有的話</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>node server.js
</code></pre><p>到<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a>查看新的風格<br><img src="/posts/CSS框架篇：如何用Node.js寫一個網頁應用？/screen-1.png" alt="screen-1.png" title=""></p>
<h2 id="Font-Awesome圖標"><a href="#Font-Awesome圖標" class="headerlink" title="Font Awesome圖標"></a>Font Awesome圖標</h2><p><a href="http://fontawesome.io/" target="_blank" rel="external">Font Awesome</a>是一個圖標庫，而它的用法跟bootstrap差不多，只需要增加<code>class</code>。上面我們用了bower，這次我們就來試一下CDN吧！只要你有CDN的連結就可以直接用了，我們直接插入到<code>&lt;head&gt;</code>內</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt;
</code></pre><p>很簡單就可以插入一個圖標</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>&lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;
</code></pre><p>而且還能使圖標轉動，這樣就能製作載入中的效果</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>&lt;i class=&quot;fa fa-spinner fa-pulse fa-fw&quot;&gt;&lt;/i&gt;
&lt;span class=&quot;sr-only&quot;&gt;載入中...&lt;/span&gt;
</code></pre><p>稍為修改一下網頁，配合bootstrap應用</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;

    &lt;!-- Vendor Stylesheet --&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;bower_components/bootstrap/dist/css/bootstrap.min.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt;

    &lt;!-- Vendor JS --&gt;
    &lt;script src=&quot;bower_components/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;bower_components/bootstrap/dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;

  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;h1&gt;嗨！世界！&lt;/h1&gt;
      &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;&gt;
        &lt;i class=&quot;fa fa-heart&quot;&gt;&lt;/i&gt;
      &lt;/button&gt;
      &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;&gt;
        &lt;i class=&quot;fa fa-spinner fa-pulse fa-fw&quot;&gt;&lt;/i&gt;
        &lt;span class=&quot;sr-only&quot;&gt;載入中...&lt;/span&gt;載入中...
      &lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>簡單幾步就能樣網頁變得沒那麼單調<br><img src="/posts/CSS框架篇：如何用Node.js寫一個網頁應用？/screen-2.png" alt="screen-2.png" title=""></p>
]]></content>
      
        
        <tags>
            
            <tag> nodejs,tutorial </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基礎篇：如何用Node.js寫一個網頁應用？]]></title>
      <url>https://3rider.com/posts/%E5%9F%BA%E7%A4%8E%E7%AF%87%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8Node.js%E5%AF%AB%E4%B8%80%E5%80%8B%E7%B6%B2%E9%A0%81%E6%87%89%E7%94%A8%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>旅程開始我們要知道一些基本的知識，這裡當然就要知道你在寫的語言是甚麼吧！<br><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/boring.gif" alt="boring.gif" title=""><br>OK！我知道這很沉悶，有誰會想聽這些呢？但我想你至少搞清楚它們的分別，因為很多同學都傻傻的<strong>分不清楚伺服器端和客戶端</strong>，用Node.js的時候就更容易搞混了，因為兩邊都是用JS麻！首先我們看看維基百科的定義：</p>
<blockquote>
<p>Node.js是一個能夠在伺服器端運行JavaScript的開放原始碼、跨平台JavaScript執行環境。</p>
</blockquote>
<h2 id="Node-js與JavaScript"><a href="#Node-js與JavaScript" class="headerlink" title="Node.js與JavaScript"></a>Node.js與JavaScript</h2><p>簡而言之<strong>Node.js就是伺服器</strong>；而<strong>JavaScript是一種語言</strong>，是一種少數能夠讓瀏覽器閱讀的語言，所以我們客戶端可以用JavaScript編寫。</p>
<p>然而在出現Node.js以前我們後端只能用PHP啊、JAVA啊甚麼的編寫，這代表開發一個網頁需要<strong>學習最少兩種語言</strong>，然後天才Ryan Dahl就想到既然我們一定要學習JavaScript，為甚麼後端不能用JavaScript寫呢？所以Node.js就這樣誕生了，Alhamdulilah！</p>
<h2 id="客戶端、伺服器端？"><a href="#客戶端、伺服器端？" class="headerlink" title="客戶端、伺服器端？"></a>客戶端、伺服器端？</h2><p>所以說，客戶端就是別人看到的網頁，瀏覽器讀得懂的，就是客戶端；伺服器端故名思義就是伺服器，想要別人瀏覽你的網頁，你需要一個伺服器寄存你的檔案，包括html、JavaScript、CSS、圖片、影片…然而伺服器當然不止這些功能，它還會連接資料庫、處理請求、控制伺服器本機資訊等等，總之除了讓客戶看到的部份，其他基本上都是伺服器端。</p>
<h2 id="教練！我好想寫網頁…"><a href="#教練！我好想寫網頁…" class="headerlink" title="教練！我好想寫網頁…"></a>教練！我好想寫網頁…</h2><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/slam-dunk-1.jpg" alt="slam-dunk-1.jpg" title="">
<p>OK！我們這就開始練習寫第一個網頁！</p>
<h6 id="1-建立項目資料夾"><a href="#1-建立項目資料夾" class="headerlink" title="1. 建立項目資料夾"></a>1. 建立項目資料夾</h6><p>首先我們要選擇一個項目的目錄，我個人喜歡放在<code>~/projects</code>的位置，假設這個項目叫<code>my-website</code></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>mkdir -p ~/projects/my-website
cd ~/projects/my-website
</code></pre><h6 id="2-初始化NPM"><a href="#2-初始化NPM" class="headerlink" title="2. 初始化NPM"></a>2. 初始化NPM</h6><p>每次建立一個node.js項目都要初始化NPM(Node Package Manager)，詳情以後再說吧！執行下面指令後需要填寫項目的資料，我們先全部按<code>Enter</code>快速建立一個項目</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>npm init
</code></pre><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/npm-init.png" alt="npm-init.png" title="">
<p>這個指令將會產生<code>package.json</code>，這個檔案的作用是儲存這個項目的資訊，包括以後安裝的模組和版本</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>{
  &quot;name&quot;: &quot;my-website&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre><h6 id="3-建立靜態網頁"><a href="#3-建立靜態網頁" class="headerlink" title="3. 建立靜態網頁"></a>3. 建立靜態網頁</h6><p>最基本的靜態頁面就是<code>index.html</code>，所以我們建立一個放靜態文件的資料夾<code>static</code>，然後把<code>index.html</code>放到裡面</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>mkdir static
touch static/index.html
</code></pre><h6 id="4-設定atom"><a href="#4-設定atom" class="headerlink" title="4. 設定atom"></a>4. 設定atom</h6><p>這裡我們先暫停一下，先設定好你的編輯器，開啟atom，把<code>my-website</code>資料夾拖拉到視窗裡面，大概會變成這樣<br><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/atom-1.png" alt="atom-1.png" title=""></p>
<p>在atom我們可以安裝各式各樣的插件，安裝方法是按下<code>ctrl + shift + p</code>，再輸入<code>install package</code><br><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/atom-2.png" alt="atom-2.png" title=""></p>
<p>來到安裝插件的頁面，搜尋<code>emmet</code>並安裝，這個插件輔助我們自動完成一些常用的語句<br><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/atom-3.png" alt="atom-3.png" title=""></p>
<h6 id="5-嗨！世界！"><a href="#5-嗨！世界！" class="headerlink" title="5. 嗨！世界！"></a>5. 嗨！世界！</h6><p>安裝好後我們回到<code>static/index.html</code>，輸入<code>html</code>，再按<code>Enter</code>就會自動生成html tags了！<br><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/atom-4.png" alt="atom-4.png" title=""><br><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/atom-5.png" alt="atom-5.png" title=""><br><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/magic.png" alt="magic.png" title=""></p>
<p>最後在<code>&lt;body&gt;</code>內加入<code>嗨！世界！</code>的tag，這將會顯示在網頁上</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;嗨！世界！&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="建立伺服器"><a href="#建立伺服器" class="headerlink" title="建立伺服器"></a>建立伺服器</h2><p>來到這裡，我們還未能夠讓網頁在瀏覽器顯示出來…但已經不遠了！還記得讓我們的檔案需要一個地方寄存嗎？沒錯就是伺服器，我們又稱這類伺服器為web hosting、網存，接下來我們就來設定伺服器。<br><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/slam-dunk-2.jpg" alt="slam-dunk-2.jpg" title=""></p>
<h6 id="6-安裝Express框架"><a href="#6-安裝Express框架" class="headerlink" title="6. 安裝Express框架"></a>6. 安裝Express框架</h6><p><a href="http://expressjs.com/" target="_blank" rel="external">Express</a>這個web框架在同行應該是無人不曉的了，不懂express不要跟其他人說你寫Node啊，它其中一個最重要的功能就是API，而且它簡化了很多設定，包括協助我們建立伺服器，express幾乎是Node.js網頁開發必備的模組了，我們用以下指令安裝</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>npm install express --save
</code></pre><p>在這裡注意一下我們安裝別人的模組全部由npm管理，一句指令就能安裝，非常方便！要緊記在JS世界內很多功能都已經有人寫好了，<strong>不要每樣功能都自己重頭開始寫</strong>，想學習就多閱讀別人的原碼，我敢說JS開發者是最不吝嗇分享自己原碼的人了；另外<code>--save</code>的作用會把模組紀錄在<code>package.json</code>，否則只會安裝在項目的<code>node_modules</code>內而不會有任何紀錄，用途以後再說。</p>
<h6 id="7-編寫伺服器"><a href="#7-編寫伺服器" class="headerlink" title="7. 編寫伺服器"></a>7. 編寫伺服器</h6><p>終於來到最後一步了，我們先建立存放伺服器原碼的檔案<code>server.js</code></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>touch server.js
</code></pre><p>這是<code>server.js</code>的原碼</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>// 使用express模組的function
let express = require(&#39;express&#39;),
    app = express();

// 開放./static資料夾
app.use(express.static(&#39;./static&#39;));

// 啟動伺服器，連接埠是慣用的3000
let server = app.listen(3000, () =&gt; {
  let { address, port } = server.address();
  console.log(`伺服器已建立${address}:${port}`);
});
</code></pre><p>這裡要注意一下當我們讀取模組的時候會使用<code>require(&#39;模組&#39;)</code>，而當中的值是基於作者而定的，最好的得知方法就是<strong>閱讀document</strong>，Node.js的文件的簡讀程度跟其他語言比較是首屈一指的，所以<strong>養成讀文件的習慣</strong>吧！而模組的檔案是放在<code>node_modules</code>內的，這資料夾內的檔案是不預計我們去修改的，所以<strong>請不要碰</strong>，當然我們可以自行寫模組，以後會再說。</p>
<h2 id="運行伺服器"><a href="#運行伺服器" class="headerlink" title="運行伺服器"></a>運行伺服器</h2><p>這真的是最後了！執行以下指令便可以運行伺服器了！</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>node server
</code></pre><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/run-node.png" alt="run-node.png" title="">
<p>接著到<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a>瀏覽我們<del>美麗</del>的網頁吧！<br><img src="/posts/基礎篇：如何用Node.js寫一個網頁應用？/hello-world.png" alt="hello-world.png" title=""></p>
]]></content>
      
        
        <tags>
            
            <tag> nodejs,tutorial </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[起始篇：如何用Node.js寫一個網頁應用？]]></title>
      <url>https://3rider.com/posts/%E8%B5%B7%E5%A7%8B%E7%AF%87%EF%BC%9A%E5%A6%82%E4%BD%95%E7%94%A8Node.js%E5%AF%AB%E4%B8%80%E5%80%8B%E7%B6%B2%E9%A0%81%E6%87%89%E7%94%A8%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>嗨！<br><img src="/posts/起始篇：如何用Node.js寫一個網頁應用？/wanna-write-website.png" alt="wanna-write-website.png" title=""><br>想寫嗎？想寫吧！這個教程將會逐步教你有效率地寫一個網頁應用，這將會是一場艱辛的旅程，做好覺悟了嗎？非常好，那麼我們就開始吧。</p>
<h2 id="我是來自純白鎮的小智"><a href="#我是來自純白鎮的小智" class="headerlink" title="我是來自純白鎮的小智"></a>我是來自純白鎮的小智</h2><p>如果小智不是住在純白鎮，或許就不會成為出色的訓練員，也不會遇到他最重要的伙伴<del>小霞</del>pikachu了！所以說在哪裡開始是很重要的，寫網頁也是，所以要寫好一個網頁應用，第一步是選系統！</p>
<p>如果你用的是Linux，這是個很明智的選擇；如果是Mac，你<del>很有錢</del>有可能會遇到一點麻煩，不過還是可以用的；如果你是用Windows，恭喜你，請你裝linux吧！<br><img src="/posts/起始篇：如何用Node.js寫一個網頁應用？/windows-bluescreen.png" alt="windows-bluescreen.png" title=""></p>
<h2 id="為甚麼要用Linux？"><a href="#為甚麼要用Linux？" class="headerlink" title="為甚麼要用Linux？"></a>為甚麼要用Linux？</h2><p>用Linux的原因不是因為Windows會藍屏，也不是因為Mac很貴，而是︓</p>
<ul>
<li>Linux系統的指令比其他系統方便</li>
<li>Node.js開發比較少出現環境問題</li>
<li>網上社群優先支援Linux</li>
<li>這篇教學會使用大量Linux指令</li>
<li><strong>沒遊戲玩，讓你專心寫程式</strong></li>
</ul>
<h2 id="那麼…安裝哪個系統？"><a href="#那麼…安裝哪個系統？" class="headerlink" title="那麼…安裝哪個系統？"></a>那麼…安裝哪個系統？</h2><p>我建議你用Ubuntu16.04，可以在<a href="https://www.ubuntu.com/download/server" target="_blank" rel="external">這裡下載</a>，因為不是這篇教學的主旨，怎樣安裝我就不多說了，不想安裝雙系統就用虛擬主機吧！</p>
<h3 id="VM-ware"><a href="#VM-ware" class="headerlink" title="VM ware"></a>VM ware</h3><p><a href="https://www.vmware.com/" target="_blank" rel="external">https://www.vmware.com/</a></p>
<h3 id="Virtual-box"><a href="#Virtual-box" class="headerlink" title="Virtual box"></a>Virtual box</h3><p><a href="https://www.virtualbox.org/" target="_blank" rel="external">https://www.virtualbox.org/</a></p>
<p>&nbsp;<br>這是Ubuntu的Unity桌面，配上<a href="https://numixproject.org/" target="_blank" rel="external">Numix主題</a>，顯得很現代化<br><img src="/posts/起始篇：如何用Node.js寫一個網頁應用？/ubuntu.png" alt="ubuntu.png" title=""></p>
<h2 id="安裝Node-js"><a href="#安裝Node-js" class="headerlink" title="安裝Node.js"></a>安裝Node.js</h2><p>系統準備好了以後，我們立即安裝Node.js，但我們不會在官方下載，因為有更好的工具，它叫<a href="https://github.com/creationix/nvm" target="_blank" rel="external">nvm（Node Version Manager）</a>，比官方的更方便，而且可以自行選擇<del>御三家</del>Node.js的版本</p>
<h6 id="1-安裝nvm"><a href="#1-安裝nvm" class="headerlink" title="1. 安裝nvm"></a>1. 安裝nvm</h6><p>打開你的terminal，輸入以下指令下載nvm</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash
</code></pre><p>然後再運行</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
</code></pre><p>全部都直接復制貼上就可以了，非常方便，最後可以用以下指令確認安裝是否成功</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>nvm
</code></pre><img src="/posts/起始篇：如何用Node.js寫一個網頁應用？/nvm.png" alt="nvm.png" title="">
<h6 id="2-用nvm安裝Node-js"><a href="#2-用nvm安裝Node-js" class="headerlink" title="2. 用nvm安裝Node.js"></a>2. 用nvm安裝Node.js</h6><p>再來就是安裝Node.js了，寫這篇的時候6.x是LTS版本，所以我們就安裝6好了，子版本不輸入會自動選擇安裝最新的版本</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>nvm install 6
nvm use 6
</code></pre><p>最後撿查一下是否裝了版本6</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>node -v
</code></pre><img src="/posts/起始篇：如何用Node.js寫一個網頁應用？/node-version.png" alt="node-version.png" title="">
<h2 id="編寫工具"><a href="#編寫工具" class="headerlink" title="編寫工具"></a>編寫工具</h2><p>我們很快就可以出發去冒險了！但在此之前請我們選擇一個適合Node.js的編寫工具，我看過很多同學在用Node Pad/++、Eclipse、Dreamweaver這些工具，我想說這些都已經過氣了！而且不適合做Node.js開發。這裡我有一些建議使用的工具</p>
<h3 id="Sublime-Text-3"><a href="#Sublime-Text-3" class="headerlink" title="Sublime Text 3"></a>Sublime Text 3</h3><p><strong>官網</strong>：<a href="http://www.sublimetext.com/" target="_blank" rel="external">http://www.sublimetext.com/</a><br><strong>價錢</strong>：$70 USD</p>
<p>我推薦sublime，最初我就是用sublime開發Node.js的，然後每次有新的編輯器我也會下載來試一下，最後還是會回到sublime。不是因為我付了錢，而是sublime的速度的確比其他快，而且也比較不吃記憶體，你可以親自下載試一下，試一下又不用錢的，<del>就像Windows一樣</del>，只是間中會有提示叫你買license<br><img src="/posts/起始篇：如何用Node.js寫一個網頁應用？/sublime-text-3.png" alt="sublime-text-3.png" title=""></p>
<h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><p><strong>官網</strong>：<a href="https://atom.io" target="_blank" rel="external">https://atom.io</a><br><strong>價錢</strong>：免費</p>
<p>第一這是免費的，而且使用的社群很大，這很重要因為很多輔助插件都是由社群開發，我們稱之為Community-driven development，就是由社群推動的開發，不錯用，但是我對記憶體使用量方面的評價有所保留，不過整體來說它是免費編輯器的第一首選，所以以後的教程都會用它來示範<br><img src="/posts/起始篇：如何用Node.js寫一個網頁應用？/atom.png" alt="atom.png" title=""></p>
<h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p><strong>官網</strong>：<a href="https://code.visualstudio.com/" target="_blank" rel="external">https://code.visualstudio.com/</a><br><strong>價錢</strong>：免費</p>
<p>Visual Studio系列，微軟的親生子，很有VS風格，速度也不錯，但個人覺得不怎麼好用，尤其是它的directory tree，總之就是用不慣，喜歡VS的可以考慮這個<br><img src="/posts/起始篇：如何用Node.js寫一個網頁應用？/vs-code.png" alt="vs-code.png" title=""></p>
<h2 id="安裝atom"><a href="#安裝atom" class="headerlink" title="安裝atom"></a>安裝atom</h2><p>如果你決定用atom，又是使用Ubuntu，可以用以下指令安裝</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>sudo add-apt-repository ppa:webupd8team/atom
sudo apt-get update
sudo apt-get install atom
</code></pre><h2 id="嗨！世界！"><a href="#嗨！世界！" class="headerlink" title="嗨！世界！"></a>嗨！世界！</h2><p>到這裡你已做好準備收服小精靈了，最好的啟程方法當然就是Hello World!了，我們寫Node.js的時後會用JavaScript，所以extension默認就是.js，我們立即建立<code>index.js</code></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>touch index.js
</code></pre><p>這是<code>index.js</code>的原碼</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>console.log(&#39;嗨！世界！&#39;)
</code></pre><p>最後執行指令運行</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>node index.js
</code></pre><img src="/posts/起始篇：如何用Node.js寫一個網頁應用？/hello-world.png" alt="hello-world.png" title="">
]]></content>
      
        
        <tags>
            
            <tag> nodejs,tutorial </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Highcharts的一個Async Drilldown實例]]></title>
      <url>https://3rider.com/posts/Highcharts%E7%9A%84%E4%B8%80%E5%80%8BAsync%20Drilldown%E5%AF%A6%E4%BE%8B/</url>
      <content type="html"><![CDATA[<p><a href="http://www.highcharts.com/" target="_blank" rel="external">Highcharts</a>在使用簡易度和功能上在眾多圖表工具之中是比較平均的一個，而它的<a href="http://www.highcharts.com/docs/chart-concepts/drilldown" target="_blank" rel="external">drilldown功能</a>是其中一個讓我選擇使用它的原因，drilldown的概念就像是<strong>逐層探索</strong>數據，由一個big picture再進入較細緻的部份，要顯示這樣的數據就需要像Highcharts這樣的工具協助了</p>
<h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>以下的例子用了這些模組</p>
<ul>
<li><a href="http://www.highcharts.com/download" target="_blank" rel="external">Highcharts 5.0.9</a></li>
<li><a href="http://jquery.com/download/" target="_blank" rel="external">jQuery 3.1.1</a></li>
<li>drilldown.js（包含在Highcharts的zip內）</li>
</ul>
<h2 id="基本Drilldown"><a href="#基本Drilldown" class="headerlink" title="基本Drilldown"></a>基本Drilldown</h2><p>以下是一個用Highcharts建立的pie chart，試試點進去<code>水果</code>或是<code>飲品</code>的區域，試用一下drilldown功能吧</p>
<p></p><p data-height="270" data-theme-id="27846" data-slug-hash="PpKLJQ" data-default-tab="js,result" data-user="auphone" data-embed-version="2" data-pen-title="Highcharts Normal Drilldown" class="codepen">See the Pen <a href="http://codepen.io/auphone/pen/PpKLJQ/" target="_blank" rel="external">Highcharts Normal Drilldown</a> by auphone (<a href="http://codepen.io/auphone" target="_blank" rel="external">@auphone</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

<h2 id="為甚麼要用Async？"><a href="#為甚麼要用Async？" class="headerlink" title="為甚麼要用Async？"></a>為甚麼要用Async？</h2><p>為甚麼我們要用Async drilldown呢？無論你叫它Async還是Lazy Load，目的一樣也是差不多的：</p>
<ul>
<li>讓頁面能較快初始化</li>
<li>減少客戶端流量</li>
<li>減少伺服器流量</li>
<li>預防request size過大的問題</li>
<li>更靈活</li>
</ul>
<h2 id="Async-Drilldown"><a href="#Async-Drilldown" class="headerlink" title="Async Drilldown"></a>Async Drilldown</h2><p>當然用Async有好處也有壞處，如果圖表只有兩層，或許用一次request取得所有數據或許是比較好的方案，因為即時請求會比較慢，而且開發也比較麻煩，但試想像一個五層、甚至十層以上的圖表，每次初始化的時候就等於<strong>多讀取了十倍</strong>以上的數據，而且<strong>用戶也不一定會點進去</strong>第十層啊，所以總括而言Lazy Load在這裡應該是一個比較好的practice吧！以下是修改成Async的版本，結果應該跟上面的例子是一樣的，這邊在<code>getDrilldownData()</code>的時候模擬了一個0.25秒的請求</p>
<p></p><p data-height="270" data-theme-id="27846" data-slug-hash="VpzNyG" data-default-tab="js,result" data-user="auphone" data-embed-version="2" data-pen-title="Highcharts Async Drilldown" class="codepen">See the Pen <a href="http://codepen.io/auphone/pen/VpzNyG/" target="_blank" rel="external">Highcharts Async Drilldown</a> by auphone (<a href="http://codepen.io/auphone" target="_blank" rel="external">@auphone</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

<h2 id="複數Series"><a href="#複數Series" class="headerlink" title="複數Series"></a>複數Series</h2><p>這是一個我在工作上花了一點時間才能做出來的，上面的例子都可以很容易地在Google找到，但當有複數的Series又需要Async的時候就是另一回事了，這情​​況很多時候會在棒形圖或折線圖之類圖表出現，而且出現率很高，就如以下例子比較兩間商店的產品，正常做法的drilldown只能顯示其中一間商店的資料，不論你按的是棒形圖或是商店。但我希望按<code>水果</code>連結時應該顯示商店A和商店B的水果產品，而不是其中一間，所以為了達到這個目的修改的地方也滿多的，主要就是用<code>e.points</code>判斷是按了一間商店、或是全部，然後我們需要由<code>addSeriesAsDrilldown()</code>改成<code>addSingleSeriesAsDrilldown()</code>才可以在drilldown內加入複數series</p>
<p></p><p data-height="270" data-theme-id="27846" data-slug-hash="RpZOJv" data-default-tab="js,result" data-user="auphone" data-embed-version="2" data-pen-title="Highcharts Async Column Drilldown" class="codepen">See the Pen <a href="http://codepen.io/auphone/pen/RpZOJv/" target="_blank" rel="external">Highcharts Async Column Drilldown</a> by auphone (<a href="http://codepen.io/auphone" target="_blank" rel="external">@auphone</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>以上其中一些部份有點hacking，雖然有很多類似的請求，但官方好像沒太大意欲進行這部份的優化，所以暫時就只能這樣吧…</p>
]]></content>
      
        
        <tags>
            
            <tag> tech </tag>
            
            <tag> tutorial </tag>
            
            <tag> highcharts </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gitly.io．一個以性能優先、新推出的免費Git服務]]></title>
      <url>https://3rider.com/posts/Gitlyio%EF%BC%8E%E4%B8%80%E5%80%8B%E4%BB%A5%E6%80%A7%E8%83%BD%E5%84%AA%E5%85%88%E3%80%81%E6%96%B0%E6%8E%A8%E5%87%BA%E7%9A%84%E5%85%8D%E8%B2%BBGit%E6%9C%8D%E5%8B%99/</url>
      <content type="html"><![CDATA[<img src="/posts/Gitlyio．一個以性能優先、新推出的免費Git服務/gitly-io-screen.png" alt="gitly-io-screen.png" title="">
<p>幾天前Git又出現了新的競爭者，它就是<a href="https://gitly.io/" target="_blank" rel="external">gitly</a>。它是由<a href="https://gitly.io/about" target="_blank" rel="external">Alexander Medvednikov</a>開發的Git版本控制系統，而重點是它可以<strong>自行託管</strong>，而且是<strong>Open Source</strong>的，雖然以上兩項暫時都還沒開放，但作者已經表示會一個月內、2017年4月10日推出這些功能。</p>
<h2 id="gitly的優點"><a href="#gitly的優點" class="headerlink" title="gitly的優點"></a>gitly的優點</h2><ul>
<li><strong>免費</strong></li>
<li>介面簡單，容易操作</li>
<li><strong>免安裝</strong>，它聲稱只需要10秒便設定好託管，雖然還沒開放沒辦法測試，但用雲端版的確是蠻快的</li>
<li>無須伺服器或資料庫</li>
<li>記憶體需求低，256MB的配置也能跑出高效能</li>
<li><p>便宜的代管方案，<strong>無限private repository</strong>，5個用戶以上才要收費，而且每個額外用戶每月只要<strong>$1美金</strong></p>
<p>但由於這還是alpha版本，所以有<strong>很多功能未完整</strong>，不過創辦人指出一些核心功能例如SSH、Pull Request、Forking等等將會在2星期內補上，到底可不可行就要到時候才知道了。但目前來看創辦人的回應速度還滿快的，而且也很常於接受其他人意見和請求，為自己增添了不少印象分，就以上來說我對這個新公司的期望還是很高的。</p>
</li>
</ul>
<h2 id="gitly適合你嗎？"><a href="#gitly適合你嗎？" class="headerlink" title="gitly適合你嗎？"></a>gitly適合你嗎？</h2><p>暫時真的只能當試用階段，可以看出來它有很大的轉變空間，但無限private repo應該是不會變的了，相比其他類似收費制度的公司例如<a href="https://bitbucket.org/product" target="_blank" rel="external">Bitbucket</a>，gitly一定是比較快，而且比其他公司都便宜，從自行託管來看設定和性能上應該會比<a href="https://about.gitlab.com/" target="_blank" rel="external">GitLab</a>來的好。   所以如果只是一些<strong>個人項目</strong>可以考慮一下轉到gitly，而且原創者已經把repo-mirroring納入下一批更新內，可以同步現有和新的repo，不想用的時候也可以立即換回去；Open Source的項目需要龐大的社群協助，就不太適合轉到這邊了；至於考慮用途的項目的還是等到正式版本再考慮吧！</p>
]]></content>
      
        
        <tags>
            
            <tag> tech </tag>
            
            <tag> writing </tag>
            
            <tag> git </tag>
            
            <tag> gitly.io </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wordpress備份自己做，從Google VM直接備份至Cloud Storage！]]></title>
      <url>https://3rider.com/posts/Wordpress%E5%82%99%E4%BB%BD%E8%87%AA%E5%B7%B1%E5%81%9A%EF%BC%8C%E5%BE%9EGoogle%20VM%E7%9B%B4%E6%8E%A5%E5%82%99%E4%BB%BD%E8%87%B3Cloud%20Storage%EF%BC%81/</url>
      <content type="html"><![CDATA[<p>CMS有不少備份工具可以選擇，尤其是Wordpress這類歷史悠久的CMS，備份插件之多讓你無從入手，但是很多插件工具都<strong>不是免費</strong>讓你使用的，特別是備份到Google Cloud Storage（GCS）這類較新的空間，目前只找到一個最像樣的由<a href="https://updraftplus.com/" target="_blank" rel="external">UpdraftPlus</a>提供的插件，它支援GCS的收費是<strong>每個網域$15美金</strong>，雖然價錢還算合理，但工程師的自尊不容許我沒試過便直接付錢買下去（<del datetime="2017-03-08T15:28:22+00:00">雖然最後還是買了</del>），所以花了點下班休息時間自己試做一下。</p>
<h2 id="一﹒準備工作"><a href="#一﹒準備工作" class="headerlink" title="一﹒準備工作"></a>一﹒準備工作</h2><p>這次還是用我熟悉的Node.js，沒有Node可以到<a href="https://3rider.com/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E5%AE%89%E8%A3%9Dnode-js%EF%BC%8C%E7%B7%A8%E5%AF%AB%E7%AC%AC%E4%B8%80%E5%80%8Bhello-world%EF%BC%81/">這裡看看</a>安裝方法，而且這次是直接從VM備份到GSC，所以很方便不需要credential認證</p>
<ul>
<li>安裝好Node.js</li>
<li>一個Google的VM instance</li>
<li>Google Cloud Platform（GCP）開放Storage服務權限</li>
<li>一個GSC Bucket</li>
</ul>
<h2 id="二﹒開放VM服務範圍（scope）"><a href="#二﹒開放VM服務範圍（scope）" class="headerlink" title="二﹒開放VM服務範圍（scope）"></a>二﹒開放VM服務範圍（scope）</h2><p>先到你的VM控制面版，拉到最下面查看啟動了的服務，如果顯示是這樣，表示已經啟動所有權限了，所以請跳過這步驟<br><img src="/posts/Wordpress備份自己做，從Google%20VM直接備份至Cloud%20Storage！/google-vm-4.png" alt="google-vm-4.png" title=""></p>
<p>如果<strong>Storage</strong>狀態是<code>Enable</code>，也可跳過這步驟，但是如果跟下圖一樣只有讀取（Read Only）權限便要繼續進行設定<br><img src="/posts/Wordpress備份自己做，從Google%20VM直接備份至Cloud%20Storage！/google-vm-2.png" alt="google-vm-2.png" title=""></p>
<p>假設你的VM沒有開啟Storage權限，先按Stop關掉你的VM，然後按Edit編輯VM的設置<br><img src="/posts/Wordpress備份自己做，從Google%20VM直接備份至Cloud%20Storage！/google-vm-1.png" alt="google-vm-1.png" title=""></p>
<p>我個人是蠻怕麻煩的，反正有防火牆，所以便直接開啟所有服務權限，最後儲存再重啟你的VM便完成了<br><img src="/posts/Wordpress備份自己做，從Google%20VM直接備份至Cloud%20Storage！/google-vm-3.png" alt="google-vm-3.png" title=""></p>
<h2 id="三﹒編寫備份程式"><a href="#三﹒編寫備份程式" class="headerlink" title="三﹒編寫備份程式"></a>三﹒編寫備份程式</h2><p>怎樣建立一個project就不多說了，可以直接到<a href="https://github.com/3rider/wp-gcp-backup" target="_blank" rel="external">我的GitHub</a>下載原碼<br>&nbsp;<br><strong>NPM模組</strong></p>
<p></p><p class="code-caption" data-lang="json" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="json">&quot;dependencies&quot;: {
    &quot;@google-cloud/storage&quot;: &quot;^0.7.0&quot;,
    &quot;adm-zip&quot;: &quot;^0.4.7&quot;,
    &quot;archiver&quot;: &quot;^1.3.0&quot;,
    &quot;bluebird&quot;: &quot;^3.5.0&quot;,
    &quot;cron&quot;: &quot;^1.2.1&quot;,
    &quot;fast-crc32c&quot;: &quot;^1.0.4&quot;,
    &quot;moment&quot;: &quot;^2.17.1&quot;,
    &quot;mysqldump&quot;: &quot;^1.3.1&quot;
}
</code></pre>
<p>&nbsp;<br>CoffeeScript原碼</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>_         = require &#39;lodash&#39; 
fs        = require &#39;fs&#39;
path      = require &#39;path&#39;
moment    = require &#39;moment&#39;
archiver  = require &#39;archiver&#39;
mysqlDump = require &#39;mysqldump&#39;
Promise   = require &#39;bluebird&#39;
CronJob   = require(&#39;cron&#39;).CronJob

# GCP
gcs = require(&#39;@google-cloud/storage&#39;)()
bucket = gcs.bucket &#39;MY-GCS-BUCKET&#39; # Your bucket name

# Params
timezone      = &#39;Asia/Hong_Kong&#39; # Cron job timezone
cronInterval  = &#39;0 0 4 * * *&#39; # Run every day at 4a.m.
bakFilename   = &quot;backup-#{moment().format(&quot;YYYYMMDDHH&quot;)}.zip&quot;

# Config
config =
  out: &quot;#{__dirname}/#{bakFilename}&quot; # Temporary zipped backup path
  wordpress:
    dir: &#39;/var/www/html/wp&#39; # Wordpress root dir
  mysql:
    host: &#39;localhost&#39;
    user: &#39;root&#39;
    password: &#39;&#39;
    database: &#39;wp&#39;
    dest: &quot;#{__dirname}/wp.sql&quot; # Temporary sql dump file path

# Dump Mysql
backupMysql = -&gt;
  return new Promise (rs, rj) -&gt;
    mysqlDump config.mysql, (err) -&gt;
      return rj err if err?
      rs config.mysql.dest

# Backup Wordpress with MySQL
createZip = (sqlPath) -&gt;
  return new Promise (rs, rj) -&gt;
    output  = fs.createWriteStream config.out
    archive = archiver &#39;zip&#39;,
      store: true
      cwd: &#39;wordpress&#39;
    archive.pipe output

    # Listener
    output.on &#39;close&#39;, -&gt;
      console.log &quot;#{archive.pointer()} total bytes&quot;
      return rs()

    output.on &#39;error&#39;, (err) -&gt;
      return rj err

    # Add SQL Dump
    archive.file sqlPath,
      name: &quot;#{config.mysql.database}.sql&quot;

    # Add Wordpress Directories
    archive.directory config.wordpress.dir, &#39;/wordpress&#39;

    # Finalize Zip
    archive.finalize()

# Push to Google Cloud Storage
pushToGCS = -&gt;
  return new Promise (rs, rj) -&gt;
    file = bucket.file bakFilename
    fs
      .createReadStream config.out
      .pipe file.createWriteStream({ gzip: true })
      .on &#39;error&#39;, (err) -&gt;
        return rj err
      .on &#39;finish&#39;, -&gt;
        console.log &#39;Pushed to GCS&#39;
        return rs()

# Cron Job
job = new CronJob 
  cronTime: cronInterval
  onTick: -&gt;
    console.log &#39;Dumping MySQL database...&#39;
    backupMysql()
      .then (sqlPath) -&gt;
        console.log &#39;Zipping Wordpress directory...&#39;
        return createZip sqlPath
      .then -&gt;
        console.log &quot;Pushing #{bakFilename} to Google cloud storage...&quot;
        return pushToGCS()
      .then -&gt;
        console.log &#39;Backup success!&#39;
      .catch (err) -&gt;
        console.error err
      .finally -&gt;
        console.log &#39;Deleting local backup files...&#39;
        try
          fs.unlinkSync config.out
          fs.unlinkSync config.mysql.dest
  start: false
  timezone: timezone

# Start Job
job.start()
console.log &#39;Monitoring...&#39;
</code></pre><p>&nbsp;<br>簡略說明一下，首先<code># GCP</code>用作設定GCS的bucket名稱，請<strong>預先在GCS建立一個bucket</strong>，這篇沒有包括建立bucket的教程；<code># Params</code>進行cron job的設定，預設了<strong>每天凌晨四點</strong>進行備份；而<code># Config</code>則設定了MySQL的連接資料，請自行修改這些設定，最後每次作業的先後次序是：</p>
<ol>
<li>備份MySQL</li>
<li>把剛備份好的MySQL連同Wordpress壓縮到<code>config.out</code>內指定的位置</li>
<li>把壓縮檔傳送至設定好的bucket內</li>
<li>最後刪除本地的備份檔案</li>
</ol>
<h2 id="四﹒運行"><a href="#四﹒運行" class="headerlink" title="四﹒運行"></a>四﹒運行</h2><p>權限設定好了，程式也有了，再來就是運行的部份了，這裡建議大家使用<a href="https://github.com/Unitech/pm2" target="_blank" rel="external">pm2</a>，它是一個強大的Node管理系統</p>
<pre><code>npm install pm2 -g
</code></pre><p>安裝好了以後用<code>pm2</code>執行index.coffee，順便為程序命名</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">pm2 start index.coffee --name wp-backup
</code></pre>
<p>然後只要等到設定好的時間，系統便會自動進行備份了，運行的log大概是以下這樣，成功了便可以到GCS查看上傳了的備份檔案</p>
<pre><code>Monitoring...
Dumping MySQL database...
Zipping Wordpress directory...
3811909 total bytes
Pushing backup-2017030900.zip to Google cloud storage...
Pushed to GCS
Backup success!
Deleting local backup files...
</code></pre><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>到最後就如上面提及到，我還是買了UpdraftPlus的插件，因為我用的是最便宜VM，而沒記錯它只有0.6GB記憶體和1個共用核心，所以基本上運行了LEMP以後也沒剩多少資源讓我再運行一個Node.js的程序了，這是我花了幾小時設定好以上所有東西以後才發覺的，無奈我不是很熟悉PHP啊…</p>
]]></content>
      
        
        <tags>
            
            <tag> tech </tag>
            
            <tag> tutorial </tag>
            
            <tag> gcp </tag>
            
            <tag> wordpress </tag>
            
            <tag> backup </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[談CoffeeScript的未來，是否被ES6趕盡殺絕？]]></title>
      <url>https://3rider.com/posts/%E8%AB%87CoffeeScript%E7%9A%84%E6%9C%AA%E4%BE%86%EF%BC%8C%E6%98%AF%E5%90%A6%E8%A2%ABES6%E8%B6%95%E7%9B%A1%E6%AE%BA%E7%B5%95%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>用CoffeeScript已經好幾年了，只要有我參與的JS項目或多或少都會有Coffee出現，可是2016年發佈的<a href="http://es6-features.org/#Constants" target="_blank" rel="external">ES6</a>是一眾Coffee愛好者<strong>最壞的消息</strong>，因為Coffee缺乏商業價值，community也比較狹窄，所以不難想像Coffee已經沒能力跟上ES6這個大改動了。那麼Coffee的未來到底是怎樣呢？最近常常被問到「<strong>用Coffee真的沒問題嗎？</strong>」這類令人痛心的說話，雖然不情願但還是做了一下資料搜集，然後很快地搜到這篇<a href="https://github.com/coffeescript6/discuss" target="_blank" rel="external">CoffeeScript 6.0 discuss</a>的文章，看來還是很多人關心這個問題嘛，點進去後我看到這個…<br><img src="/posts/談CoffeeScript的未來，是否被ES6趕盡殺絕？/rip-coffee.png" alt="rip-coffee.png" title=""><br>&nbsp;<br>我的心臟頓時冷了一下，我立刻代入了<a href="https://zh.wikipedia.org/wiki/%E9%BA%A5%E7%94%B0%E6%8D%95%E6%89%8B" target="_blank" rel="external">麥田捕手</a>裡Holden的心境，我憎恨這個社會！為甚麼要這樣對我的Coffee！可是當我忍痛繼續看下去時，卻讓我看到了希望，就是<a href="https://rawgit.com/jashkenas/coffeescript/2/docs/v2/index.html" target="_blank" rel="external">CoffeeScript 2.0</a>！我立刻收回剛剛說Coffee沒能力的話，心境也瞬間變回桑地亞哥，但這次不是在夢境，而是我真的看到獅子了！ </p>
<h2 id="CoffeeScript-2-0"><a href="#CoffeeScript-2-0" class="headerlink" title="CoffeeScript 2.0"></a>CoffeeScript 2.0</h2><p>CoffeeScript 2.0是<strong>根據ES2015+的功能來開發</strong>的，雖然它某些部份不能向後兼容以往的Coffee版本，但總比不兼容ES6+來得好，就是說我以後可以<strong>理直氣壯地跟別人說我用CoffeeScript開發</strong>了！讓我們期待它的發展吧，每次看到Coffee這種syntax的比較我就知道自己沒辦法放棄它啊！<br><img src="/posts/談CoffeeScript的未來，是否被ES6趕盡殺絕？/coffee-compare.png" alt="coffee-compare.png" title=""></p>
<p>無論別人怎樣貶低Coffee，只要有愛就行了！好Coffee，不用嗎？</p>
]]></content>
      
        
        <tags>
            
            <tag> writing </tag>
            
            <tag> es6 </tag>
            
            <tag> coffee </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[看完Google提供的便宜方案，我決定從AWS轉到GCP了！]]></title>
      <url>https://3rider.com/posts/%E7%9C%8B%E5%AE%8CGoogle%E6%8F%90%E4%BE%9B%E7%9A%84%E4%BE%BF%E5%AE%9C%E6%96%B9%E6%A1%88%EF%BC%8C%E6%88%91%E6%B1%BA%E5%AE%9A%E5%BE%9EAWS%E8%BD%89%E5%88%B0GCP%E4%BA%86%EF%BC%81/</url>
      <content type="html"><![CDATA[<p>第一次聽到<a href="https://cloud.google.com/" target="_blank" rel="external">GCP（Google Cloud Platform）</a>大概是2016年初左右吧，因為機緣巧合在研究Big Data的時候看到它的Big Query，而且還能夠試用，我當然不會放過啊，當時忘記了是30天還是60天試用，提供的額度跟現在一樣是$300美金，試了一段時間發現它有些缺點不能達到我的項目要求，所以就沒有再用了。那時候對它的印象就是介面很好看，然後它的<a href="https://cloud.google.com/compute/" target="_blank" rel="external">Computer Engine</a>（Google的虛擬機器）很快，自帶的網頁版SSH很好用，總之印象還是很好的，但可能是一直在用AWS，Big Query又不太用得到，而且當時個人方面也沒實際需要用到一個VM，所以也不太上心。</p>
<h2 id="轉成GCP的契機"><a href="#轉成GCP的契機" class="headerlink" title="轉成GCP的契機"></a>轉成GCP的契機</h2><p>寫這個網誌一開始的時候也是用AWS的，直至幾天前在Hacker News看到這篇<a href="https://news.ycombinator.com/item?id=13755673" target="_blank" rel="external">Ask HN: Is S3 down?</a>，當然文章的內容不是重點，看完第一個回覆真的讓我一頭霧水，原本是在問AWS的問題，卻來了一堆回覆討論GCP，然後剛好我很閒（在上班）看看他們討論些甚麼，發現很多關於價錢的比較，看到之後我二話不說立刻到GCP查價目表，一看之下真的嚇了我一大跳，規格差不多的VM價錢比AWS<strong>便宜了一倍</strong>，這裡不是說AWS貴，但是<strong>GCP真的很划算</strong>，尤其是我這些只用網頁寄存的用戶，經過一番研究（在上班）後，最後我決定在GCP設定一台VM，然後為這網誌搬家了。但話雖如此，其實AWS跟GCP各有好處，只是我選擇了GCP作個人用途，而工作上我還是在用AWS的！<del datetime="2017-03-06T12:25:01+00:00">因為買了RI（Reserved Instance）…</del></p>
<h2 id="免費方案比較"><a href="#免費方案比較" class="headerlink" title="免費方案比較"></a>免費方案比較</h2><p><strong>Google Cloud Platform</strong></p>
<ul>
<li>需要登記信用卡</li>
<li>體驗60天</li>
<li>$300美金限額</li>
<li>比較寬鬆的服務限制，直至花光限額或過了60天</li>
</ul>
<p><strong>AWS</strong></p>
<ul>
<li>需要登記信用卡</li>
<li>體驗一年</li>
<li>沒有限額</li>
<li>只能用<a href="https://aws.amazon.com/tw/free/" target="_blank" rel="external">免費方案包含</a>的服務</li>
</ul>
<h2 id="價錢比較"><a href="#價錢比較" class="headerlink" title="價錢比較"></a>價錢比較</h2><p>以下我只列出最基本的On-Demand收費，就這樣已經看出差別了，就以普遍的單核3.75GB記憶體作比較，GCP每小時$0.055，AWS則要$0.098，差不多相差了<strong>一倍</strong>！<br>&nbsp;<br><strong>Google Cloud Platform</strong><br><img src="/posts/看完Google提供的便宜方案，我決定從AWS轉到GCP了！/gpc-pricing.png" alt="gpc-pricing.png" title=""> </p>
<p><strong>AWS</strong><br><img src="/posts/看完Google提供的便宜方案，我決定從AWS轉到GCP了！/aws-pricing.png" alt="aws-pricing.png" title=""></p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>因為它們提供的服務太多，這裡不逐一比較了，反正兩邊都能免費試用，看自己的需要選擇吧</p>
<ul>
<li>AWS<strong>每張信用卡</strong>有<strong>一年免費</strong>，所以可以免費讓你用很久</li>
<li>GPC的限額制可以讓你免費<strong>測試較高效能</strong>的服務，AWS只能用比較基本的服務</li>
<li>兩邊的監測系統差不多，個人覺得GCP介面的比較人性化</li>
<li>兩邊都自帶網頁版SSH，但是AWS需要用Java，而且用起來比較慢</li>
<li>AWS提供<strong>較多地區選擇</strong>，特別是海外，但是<strong>GCP有台灣</strong>而AWS最近的只有日本</li>
<li>如果不預付暫時來看是<strong>GCP比較便宜</strong></li>
<li>某M公司就不說了，介面不好用、性能慢、收費貴、下刪一千字…</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> writing </tag>
            
            <tag> gcp </tag>
            
            <tag> aws </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[免費把網頁升級至HTTPs！Let's Encrypt + Nginx的SSL安裝教學]]></title>
      <url>https://3rider.com/posts/%E5%85%8D%E8%B2%BB%E6%8A%8A%E7%B6%B2%E9%A0%81%E5%8D%87%E7%B4%9A%E8%87%B3HTTPs%EF%BC%81Lets%20Encrypt%20+%20Nginx%E7%9A%84SSL%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8/</url>
      <content type="html"><![CDATA[<p><a href="https://letsencrypt.org/" target="_blank" rel="external">Let’s Encrypt</a>已經推出一段時間了，它是一個多方認可的HTTP加密服務，而且還是<strong>免費</strong>的，這下我們不用再支付昂貴的年費了！</p>
<h2 id="為麼要用SSL？"><a href="#為麼要用SSL？" class="headerlink" title="為麼要用SSL？"></a>為麼要用SSL？</h2><ul>
<li>SSL幫助加密你的網頁傳輸，防止資料外流</li>
<li>讓瀏覽器信任你的網頁</li>
<li>付費系統等等必須使用SSL</li>
<li>現在都<strong>免費</strong>了，還在考慮甚麼…</li>
</ul>
<h2 id="Let’s-Encrypt的限制"><a href="#Let’s-Encrypt的限制" class="headerlink" title="Let’s Encrypt的限制"></a>Let’s Encrypt的限制</h2><ul>
<li>因為加密了所以速度比較慢，這是HTTPs的缺點</li>
<li>90天要更新一次證書</li>
</ul>
<h2 id="一﹒安裝certbot"><a href="#一﹒安裝certbot" class="headerlink" title="一﹒安裝certbot"></a>一﹒安裝certbot</h2><p>這裡就介紹常用的Ubuntu + Nginx的安裝方法，其實就只是根據官方供的<a href="https://certbot.eff.org/" target="_blank" rel="external">certbot</a>的指示做，但還是簡單講一下吧 首先來安裝letsencrypt</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">sudo apt-get install letsencrypt
</code></pre>
<p>  然後就是生產證書，把以下的指令修改成你的<strong>網域</strong>和網頁的<strong>根目錄</strong>，假設你的網域是<code>example</code>，根目錄是<code>/var/www/example</code></p>
<pre><code>letsencrypt certonly --webroot -w /var/www/example -d example.com -d www.example.com
</code></pre><p>上面指令將會在<code>/etc/letsencrypt/live/example.com/</code>產生四個檔案</p>
<ul>
<li>cert.pem</li>
<li>chain.pem</li>
<li>fullchain.pem</li>
<li>privkey.pem</li>
</ul>
<h2 id="二﹒設定Nginx"><a href="#二﹒設定Nginx" class="headerlink" title="二﹒設定Nginx"></a>二﹒設定Nginx</h2><p>我們把本來使用的<code>port 80</code>換成<code>port 443</code>，然後加入<code>fullchain.pem</code>和<code>privkey.pem</code>兩張證書，就像這樣</p>
<pre><code>server {
    listen *:443 ssl http2;
    listen [::]:443 ssl http2;

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

    root /var/www/example;

    ...
}
</code></pre><p>然後我們可以選擇把所有http的請求自動轉到https</p>
<pre><code>server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name example.com www.example.com;
    return 301 https://$server_name$request_uri;
}
</code></pre><p>最後從新載入nginx的設定就大功告成了！</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>sudo systemctl reload nginx
</code></pre><h2 id="自動更新證書"><a href="#自動更新證書" class="headerlink" title="自動更新證書"></a>自動更新證書</h2><p>由於Let’s Encrypt的限制，證書需要每90天更新一次，所以certbot很貼心地提供了一個更新的指令讓我們使用，而且也建議我們用<code>cron</code>或是<code>systemd</code>每天檢查兩次，我們不用擔心更新過多的問題，因為<strong>快到期之前</strong>即使運行了指令它也是<strong>不會更新</strong>的，所以我們可以每天的1AM和1PM各檢查更新一次，這樣就做到自動更新的效果了</p>
<p>這裡我選擇用crontab</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>sudo crontab -e
</code></pre><p>初次使用應該會出現以下畫面，個人習慣用nano，所以選2</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>no crontab for root - using an empty one

Select an editor.  To change later, run &#39;select-editor&#39;.
  1. /bin/ed
  2. /bin/nano        &lt;---- easiest
  3. /usr/bin/vim.basic
  4. /usr/bin/vim.tiny

Choose 1-4 [2]:
</code></pre><p>選擇以後會跳到編輯版面，在最下面輸入以下語句</p>
<pre><code>10 1,13 * * * /usr/bin/letsencrypt renew &gt;&gt; /var/log/le-renew.log
15 1,13 * * * /etc/init.d/nginx reload
</code></pre><p>最後按<code>Ctrl + X</code>儲存後系統便會依據時間自動執行了！</p>
]]></content>
      
        
        <tags>
            
            <tag> tech </tag>
            
            <tag> tutorial </tag>
            
            <tag> ssl </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[棄坑從SPA回到Wordpress，最大的敵人是SEO？]]></title>
      <url>https://3rider.com/posts/%E6%A3%84%E5%9D%91%E5%BE%9ESPA%E5%9B%9E%E5%88%B0Wordpress%EF%BC%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B5%E4%BA%BA%E6%98%AFSEO%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>由最初決定建立這個網誌開始已經一個月了，作為一個開發者，當然想自己動手建立屬於自己風格的網頁，所以就決定用Wordpress做後端提供API，然後以熟悉的Angular1寫一個Single Page Application（SPA）​，因為WP的API很完善所以花不到兩天就把它寫出來了。可是當我放到Google Webmasters後發現<strong>SEO未如理想</strong>，而且Google只搜到我不想讓人看到的WP頁面，所以我又花了幾天時間把WP改成private連接埠，可是效果也不是很好，經過一些資料搜集後最後還是決定回到Wordpress了…</p>
<h2 id="為甚麼SPA的SEO這麼糟糕？"><a href="#為甚麼SPA的SEO這麼糟糕？" class="headerlink" title="為甚麼SPA的SEO這麼糟糕？"></a>為甚麼SPA的SEO這麼糟糕？</h2><p>現在很多SPA都是用client-side rendering的，意思就是在前端做運算，例如用JS產生一些HTML碼，所以當Google這些搜尋引擎嘗試讀取你的網頁它通常都讀不到JS生產出來的東西，而且文章的頁面也都是用JS產生出來的，如果不提供一個sitemap結果就像我這樣只能搜到首頁</p>
<h2 id="如果真的要用SPA怎麼辦？"><a href="#如果真的要用SPA怎麼辦？" class="headerlink" title="如果真的要用SPA怎麼辦？"></a>如果真的要用SPA怎麼辦？</h2><p>這是我部份的資料搜集，理​論上就是把你的網頁改為server rendering，其中一個方法在初次瀏覽的時候產生一個緩存，下次請求的時候便會直接回傳那個緩存了的網頁，讓搜尋引擎可以立刻讀到你的網頁內容，做法就是自行設定一個rendering server例如<a href="http://phantomjs.org/" target="_blank" rel="external">phantomJS</a>，但這方法有點麻煩，而且我的VM也不太夠資源做，所以再試了其他人提供的服務，例如<a href="https://prerender.io/" target="_blank" rel="external">prerender.io</a>、<a href="https://www.seo4ajax.com/" target="_blank" rel="external">seo4ajax</a>等等，前者跟我的網頁好像無緣，試很久還是不太行，後者就是太貴了，​而且我發現很多方法都是用<a href="https://developers.google.com/webmasters/ajax-crawling/docs/specification#bidirectional-between--url-to-_escaped_fragment_-url" target="_blank" rel="external">_escaped<em>fragment</em></a>告訴Google讀取的，但是根據Google <a href="https://webmasters.googleblog.com/2015/10/deprecating-our-ajax-crawling-scheme.html" target="_blank" rel="external">2015年末的報告</a>好像不建議這方法，所以最後還是打消了這念頭，果斷放棄SPA…</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>最後就做一個總結，雖然還沒有看到轉成WP的效果，但是這些應該是錯不了的</p>
<ul>
<li>SPA的SEO暫時還是比較差</li>
<li>用前端JS產生HTML很大程上影響到SEO</li>
<li>SPA需要用緩存解決SEO問題</li>
<li>還是wordpress比較適合初學者</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> writing </tag>
            
            <tag> wordpress </tag>
            
            <tag> spa </tag>
            
            <tag> seo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[輕鬆學習RESTful API，人見人愛的簡約設計！]]></title>
      <url>https://3rider.com/posts/%E8%BC%95%E9%AC%86%E5%AD%B8%E7%BF%92RESTful%20API%EF%BC%8C%E4%BA%BA%E8%A6%8B%E4%BA%BA%E6%84%9B%E7%9A%84%E7%B0%A1%E7%B4%84%E8%A8%AD%E8%A8%88%EF%BC%81/</url>
      <content type="html"><![CDATA[<p>REST是一種風格，RESTful API則是符合REST風格的API，正所謂<strong>less is more</strong>，REST完美地表這個精神，但是跟隨這風格一點也不簡單，要成為人見人愛的REST開發者，就應該更小心不要犯常見的錯誤  </p>
<h2 id="一﹒５個常用Method"><a href="#一﹒５個常用Method" class="headerlink" title="一﹒５個常用Method"></a>一﹒５個常用Method</h2><p>RESTful API常用的method有五種</p>
<ul>
<li>GET - 取得資料</li>
<li>POST - 寫入或增加資料</li>
<li>PUT - 更新整個資料</li>
<li>PATCH - 更新資料裡面的一部分</li>
<li>DELETE - 刪除資料</li>
</ul>
<h2 id="二﹒常犯錯誤１：不要用錯Method！"><a href="#二﹒常犯錯誤１：不要用錯Method！" class="headerlink" title="二﹒常犯錯誤１：不要用錯Method！"></a>二﹒常犯錯誤１：不要用錯Method！</h2><p>上面指出的５個method已經是最基本的了，不要再讓自己局限於GET、POST兩種，要緊記API是<strong>讓別人看</strong>的，RESTful的原意是<strong>stateless</strong>，是<strong>不需要有協議</strong>也能很容易知道如果使用，這方面必須用對method才能達到這個目的，以下列出一個簡單的CRUD例子</p>
<p><strong>取得生果清單</strong></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>GET /fruits
</code></pre><p><strong>取得生果清單裡面的蘋果</strong>，假設蘋果的<code>id</code>是1</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>GET /fruits/1
</code></pre><p><strong>增加橘子到生果清單</strong></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>POST /fruits
{
  id: 2,
  name: &quot;Orange&quot;,
  description: &quot;This is an orange&quot;
}
</code></pre><p><strong>更新橘子的description</strong>，用<code>PATCH</code>的意義就是只改部份，而不會進行覆蓋，以下例子就是只改<code>description</code>而不改<code>name</code></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>PATCH /fruits/2
{
  description: &quot;This is a juicy orange&quot;
}
</code></pre><p>  <strong>把橘子的record變成梨子</strong>，因為我們用<code>PUT</code>，所以這裡連原有的<code>description</code>也會被覆蓋掉了</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>PUT /fruits/2
{
  name: &quot;Pear&quot;
}
</code></pre><p><strong>刪除蘋果</strong></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>DELETE /fruits/1
</code></pre><h2 id="三﹒常犯錯誤２：不要胡亂命名"><a href="#三﹒常犯錯誤２：不要胡亂命名" class="headerlink" title="三﹒常犯錯誤２：不要胡亂命名"></a>三﹒常犯錯誤２：不要胡亂命名</h2><p>原因同上，RESTful API的URL不應該出現動詞，所以<strong>不要這樣寫</strong></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>GET /getFruits
</code></pre><p>另外不是unique的話請緊記用<strong>複數</strong>命名，所以也<strong>不要這樣寫</strong></p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>GET /frust
</code></pre><p>所以應該寫成這樣才正確</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>GET /fruits
</code></pre><h2 id="四﹒利用Sub-resource表示關聯性"><a href="#四﹒利用Sub-resource表示關聯性" class="headerlink" title="四﹒利用Sub resource表示關聯性"></a>四﹒利用Sub resource表示關聯性</h2><p>這個設計可以令使用者逐層探索你的API，以下就是一個常見的例子，首先我們取得<code>product</code>的清單</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>GET /products
</code></pre><pre><code>[
  {
    id: 1,
    name: &quot;fruits&quot;
  },
  {
    id: 2,
    name: &quot;drinks&quot;
  }
]
</code></pre><p>  由於是一個複數的請求，所以我們會取得一個<code>Array</code>，而清單入面不會有太多資料，我們只知道有<code>fruits</code>和<code>drinks</code>可以選擇，我們就選擇<code>fruits</code>看看</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>GET /products/1
</code></pre><pre><code>{
  id: 1,
  name: &quot;fruits&quot;,
  items: [
    {
      id: 1,
      name: &quot;apple&quot;
    },
    {
      id: 2,
      name: &quot;orange&quot;
    }
  ]
}
</code></pre><p>在<code>fruits</code>裡面我們想看橘子的資料，所以我們這樣請求</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>GET /products/1/items/2
</code></pre><pre><code>{
  id: 1,
  name: &quot;orange&quot;,
  description: &quot;This is an orange&quot;
}
</code></pre><p>到這樣有沒有發現哪裡怪怪的？沒有發現嗎？請繼續往下看吧！  </p>
<h2 id="五﹒使用HATEOAS"><a href="#五﹒使用HATEOAS" class="headerlink" title="五﹒使用HATEOAS"></a>五﹒使用HATEOAS</h2><p><a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">HATEOAS</a> 是其中一種RESTful API的條件，之前不是提到REST是一種<code>stateless</code>的設計嗎？那麼上面的例子裡由選擇生果的時候開始便是<strong>用猜</strong>的方式去取得<code>sub resource</code>的，這不是一個很好的練習，所以我們要用HATEOAS，我們可以加插<code>link</code>，讓使用者知道如何查詢下一層的資料，以下是改善後的例子</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>GET /products
</code></pre><pre><code>[
  {
    id: 1,
    name: &quot;fruits&quot;,
    _links: {
      self: {
        href: &quot;/products/1&quot;
      }
    }
  }
]
</code></pre><h2 id="六﹒給你的API一個版本"><a href="#六﹒給你的API一個版本" class="headerlink" title="六﹒給你的API一個版本"></a>六﹒給你的API一個版本</h2><p>最後來談一下版本的問題，雖然跟REST沒太大關係，但加版本是一個不錯的練習，因為將來即使一點小改動都可能會影響到現有的用家，所以最好的情況就是開始的時候便加入版本例如叫<code>v1</code>，以後有不能向後兼容的情況便增一個<code>v2</code>的API</p>
<pre><code>GET /api/v1/products
</code></pre><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>說到底REST都只是一種風格，就算不跟隨也不會影響API的功能，如果不喜歡也沒關係，但有時候我們不一定是開發的那方，也會有使用的時候，經常認識一下一些趨勢相信必定是有利無害的！</p>
]]></content>
      
        
        <tags>
            
            <tag> tech </tag>
            
            <tag> tutorial </tag>
            
            <tag> restful </tag>
            
            <tag> api </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[管理網頁緩存原來可以很簡單！]]></title>
      <url>https://3rider.com/posts/%E7%AE%A1%E7%90%86%E7%B6%B2%E9%A0%81%E7%B7%A9%E5%AD%98%E5%8E%9F%E4%BE%86%E5%8F%AF%E4%BB%A5%E5%BE%88%E7%B0%A1%E5%96%AE%EF%BC%81/</url>
      <content type="html"><![CDATA[<p>瀏覽器緩存是<a href="https://en.wikipedia.org/wiki/Web_cache" target="_blank" rel="external">web cache</a>的一種，主要作用就是緩存靜態的檔案，降低下次請求時的流量，所以這個設計對於數據傅輸速度不快的移動裝置用家非常有用，可是緩存處理不當會另理應需要更新的檔案無法更新，降低了用家的體驗，以下就來看看解決的方法！</p>
<h2 id="一﹒手動清除緩存"><a href="#一﹒手動清除緩存" class="headerlink" title="一﹒手動清除緩存"></a>一﹒手動清除緩存</h2><p>這方法只會清除本地緩存，是給開發者的方法，以Chrome做例子，最簡單的做法就是按<code>F12</code>開啟console，在<code>更新按鈕</code>上按<code>右鍵</code>，便會出現<code>Empty Cache and Hard Reload</code>的選項，其他瀏覽器可以參考<a href="http://www.refreshyourcache.com/en/home/" target="_blank" rel="external">這篇文章</a><br><img src="/posts/管理網頁緩存原來可以很簡單！/chrome-cache.png" alt="chrome-cache.png" title="">  </p>
<h2 id="二﹒伺服器設定"><a href="#二﹒伺服器設定" class="headerlink" title="二﹒伺服器設定"></a>二﹒伺服器設定</h2><p>我們可以在伺服器設定<strong>永遠不緩存</strong>，事先聲明，這<strong>不是一個好方法</strong>，緩存有很多好處，所以<strong>盡量不要用</strong>這方法吧！以下的例子都是參考<a href="http://stackoverflow.com/questions/49547/how-to-control-web-page-caching-across-all-browsers" target="_blank" rel="external">這篇QA</a>的，我們只要將伺服器的HTTP header設定成這樣，下次就不會有緩存了…</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">Cache-Control: no-cache, no-store, must-revalidate
Pragma: no-cache
Expires: 0
</code></pre>
<p>以下是一些常用的設定</p>
<ol>
<li>Node.js<br><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="js">res.header(&#39;Cache-Control&#39;, &#39;no-cache, private, no-store, must-revalidate, max-stale=0, post-check=0, pre-check=0&#39;);
</code></pre>
</li>
<li>PHP<br><p class="code-caption" data-lang="php" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="php">header(&quot;Cache-Control: no-cache, no-store, must-revalidate&quot;); // HTTP 1.1.
header(&quot;Pragma: no-cache&quot;); // HTTP 1.0.
header(&quot;Expires: 0&quot;); // Proxies.
</code></pre>
</li>
<li>Nginx<br><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="bash">add_header Cache-Control no-cache;
</code></pre>
</li>
<li>Apache<br><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="bash">Header set Cache-Control &quot;no-cache, no-store, must-revalidate&quot;
Header set Pragma &quot;no-cache&quot;
Header set Expires 0
</code></pre>
</li>
</ol>
<h2 id="三﹒利用cache-busting"><a href="#三﹒利用cache-busting" class="headerlink" title="三﹒利用cache busting"></a>三﹒利用cache busting</h2><p>另外一個方法是<a href="https://css-tricks.com/strategies-for-cache-busting-css/" target="_blank" rel="external">cache busting</a> ，也是比較好的做法，特別適用於vendor.js、app.js這類經常會改動原碼，但不會改變名稱的檔案，透過增加一個額外的<code>query字串</code>，讓瀏覽器判斷這個檔案需要更新，這樣就可以保留緩存功能又能防止誤判的情況</p>
<p></p><p class="code-caption" data-lang="html" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="html">&lt;script src=&quot;app.js?v=1&quot;&gt;&lt;/script&gt;
</code></pre>
<p>&nbsp;<br>除了加版本，我們還可以增加一個<code>timestamp字串</code>，效果基本上等於沒有緩存，但這個方法還是比修改伺服器的設定好，因為我們可以只控制個別不想做緩存檔案，而不是全部不使用</p>
<p></p><p class="code-caption" data-lang="html" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="html">&lt;script&gt;
  document.write(&quot;&lt;script src=\&quot;app.js?v=&quot; + new Date().getTime() + &quot;\&quot;&gt;&lt;\/script&gt;&quot;);
&lt;/script&gt;
</code></pre>
<h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>有時候很多這些細微的東西很容易會被忽略掉，遇到的時候又用不正規的方法處理掉，花點時間研究一下，其實很容易就可以解決了！</p>
]]></content>
      
        
        <tags>
            
            <tag> tech </tag>
            
            <tag> tutorial </tag>
            
            <tag> cache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十分鐘試玩Elasticsearch，最快NoSQL db之一！]]></title>
      <url>https://3rider.com/posts/%E5%8D%81%E5%88%86%E9%90%98%E8%A9%A6%E7%8E%A9Elasticsearch%EF%BC%8C%E6%9C%80%E5%BF%ABNoSQL%20db%E4%B9%8B%E4%B8%80%EF%BC%81/</url>
      <content type="html"><![CDATA[<p>因為工作的關係很多時候會接觸到<strong>資料分析</strong>的部份，所以需要一個靈活而快速的資料庫協助，而Elasticsearch （ES）是暫時測試過最快的NoSQL之一，雖然它不適合作主數據庫（讀寫會有誤差），但作為索引引擎它可說是一流的！  </p>
<h2 id="一﹒安裝Elasticsearch"><a href="#一﹒安裝Elasticsearch" class="headerlink" title="一﹒安裝Elasticsearch"></a>一﹒安裝Elasticsearch</h2><p>因為這次純屬試玩，所以也不做多餘的設定了，直接用官方提供的免安裝zip體驗一下，首先到<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="external">官方下載</a>目前最新的5.2版本壓縮檔，下載好了以後解壓，然後用它提供的binary啟動</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">cd elasticsearch-5.2.0
./bin/elasticsearch
</code></pre>
<p>啟動後可以在<a href="http://localhost:9200" target="_blank" rel="external">http://localhost:9200</a>查看資料庫的狀態</p>
<p></p><p class="code-caption" data-lang="json" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="json">{
  &quot;name&quot; : &quot;ddBd3a_&quot;,
  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,
  &quot;cluster_uuid&quot; : &quot;megP9_F-S06WuK6hJAVrdw&quot;,
  &quot;version&quot; : {
    &quot;number&quot; : &quot;5.2.0&quot;,
    &quot;build_hash&quot; : &quot;24e05b9&quot;,
    &quot;build_date&quot; : &quot;2017-01-24T19:52:35.800Z&quot;,
    &quot;build_snapshot&quot; : false,
    &quot;lucene_version&quot; : &quot;6.4.0&quot;
  },
  &quot;tagline&quot; : &quot;You Know, for Search&quot;
}
</code></pre>
<h2 id="二﹒安裝Sense插件"><a href="#二﹒安裝Sense插件" class="headerlink" title="二﹒安裝Sense插件"></a>二﹒安裝Sense插件</h2><p>需然ES可以用HTTP請求執行指令，例如<code>CURL</code>，但還是有介面比較方便，所以我們可以安裝Chrome的<a href="https://chrome.google.com/webstore/detail/sense-beta/lhjgkmllcaadmopgmanpapmpjgmfcfig" target="_blank" rel="external">Sense</a>插件執行指令<br><img src="/posts/十分鐘試玩Elasticsearch，最快NoSQL%20db之一！/es-query.png" alt="es-query.png" title=""></p>
<h2 id="三﹒了解更多Elasticsearch"><a href="#三﹒了解更多Elasticsearch" class="headerlink" title="三﹒了解更多Elasticsearch"></a>三﹒了解更多Elasticsearch</h2><p>NoSQL就是非關係數據庫，很多時候都比較靈活，例如不需要建立table、也不需要再畫麻煩的ERD了！但當然也可以設定一些架構（Schema）限制資料輸入，但這篇就不說明這些了，想了解更多可以到<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html" target="_blank" rel="external">這裡</a>學習學習，另外關於它<code>index</code>和<code>type</code>的概念可以到<a href="https://www.elastic.co/blog/index-vs-type" target="_blank" rel="external">官方blog</a>了解</p>
<h2 id="四﹒核心指令"><a href="#四﹒核心指令" class="headerlink" title="四﹒核心指令"></a>四﹒核心指令</h2><p>核心指令分為４種，就是常見的CRUD</p>
<ul>
<li>GET：查詢</li>
<li>POST：寫入</li>
<li>PUT：更新或寫入（<code>upsert</code>功能，當沒有可更新的條件便寫入）</li>
<li>DELETE：刪除</li>
</ul>
<p>而它用的是RESTful風格的請求，以下是一些例子，當中有使用到<code>search</code>的地方就如SQL的<code>where</code>一樣，更多用法可以參考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html" target="_blank" rel="external">官方的教學</a></p>
<p></p><p class="code-caption" data-lang="json" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="json">PUT twitter/tweet/1
{
    &quot;user&quot; : &quot;peter&quot;,
    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,
    &quot;message&quot; : &quot;trying out Elasticsearch update&quot;
}

POST twitter/tweet
{
    &quot;user&quot; : &quot;john&quot;,
    &quot;post_date&quot; : &quot;2009-11-15T14:12:12&quot;,
    &quot;message&quot; : &quot;trying out Elasticsearch&quot;
}

GET twitter/tweet/1

GET twitter/tweet/_search

DELETE twitter/tweet/1
</code></pre>
<h2 id="五﹒基本Searching"><a href="#五﹒基本Searching" class="headerlink" title="五﹒基本Searching"></a>五﹒基本Searching</h2><p>以下的例子我們建立了２個<code>user</code>，分別是<code>peter</code>和<code>john</code>，然後用了３種搜尋方法</p>
<ul>
<li>Exists：如果搜尋的<code>field</code>存在</li>
<li>Term：搜尋的值等同於數據記錄的值</li>
<li>Range：數據記錄的值在兩個搜尋值之間</li>
</ul>
<p>&nbsp;<br>除此之外還有很多用法，可以到<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search.html" target="_blank" rel="external">這裡</a>查看詳細資料，以下例子先建立了兩個<code>user</code>，然後再用上面提到的３種方法搜尋</p>
<p></p><p class="code-caption" data-lang="json" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="json">PUT twitter/tweet/1
{
    &quot;user&quot; : &quot;peter&quot;,
    &quot;age&quot;: 10
}

PUT twitter/tweet/2
{
    &quot;user&quot; : &quot;john&quot;,
    &quot;age&quot;: 20,
    &quot;gender&quot;: &quot;Male&quot;
}

GET twitter/tweet/_search
{
    &quot;query&quot;: {
        &quot;exists&quot;: {
            &quot;field&quot;: &quot;gender&quot;
        }
    }
}

GET twitter/tweet/_search
{
    &quot;query&quot;: {
        &quot;term&quot;: {
           &quot;user&quot;: {
              &quot;value&quot;: &quot;peter&quot;
           }
        }
    }
}

GET twitter/tweet/_search
{
    &quot;query&quot;: {
        &quot;range&quot;: {
           &quot;age&quot;: {
              &quot;from&quot;: 19,
              &quot;to&quot;: 30
           }
        }
    }
}
</code></pre>
<h2 id="六﹒Aggregation"><a href="#六﹒Aggregation" class="headerlink" title="六﹒Aggregation"></a>六﹒Aggregation</h2><p>ES在<code>Aggregation</code>方面最特出，因為它在速度上比其他資料庫快很多，而這功能主要就是幫我們做計算，搜尋並合併（Map-Reduce），縮減成一些有意義的數據，所以對於分析方面是非常有利的，我們就以上例子試用<code>Aggregation</code>計算<code>總年齡</code>和<code>平均年齡</code></p>
<pre><code>GET twitter/tweet/_search
{
    &quot;size&quot;: 0, 
    &quot;aggs&quot;: {
        &quot;sumAge&quot;: {
            &quot;sum&quot;: {
                &quot;field&quot;: &quot;age&quot;   
            }
        }
    }
}

GET twitter/tweet/_search
{
    &quot;size&quot;: 0, 
    &quot;aggs&quot;: {
        &quot;avgAge&quot;: {
            &quot;sum&quot;: {
                &quot;field&quot;: &quot;age&quot;   
            }
        }
    }
}
</code></pre><h2 id="七﹒後記"><a href="#七﹒後記" class="headerlink" title="七﹒後記"></a>七﹒後記</h2><p>Elasticsearch還有很多好玩的功能待大家發掘，以後有機會再補上一些進階的用法讓各位參考！</p>
]]></content>
      
        
        <tags>
            
            <tag> tech </tag>
            
            <tag> tutorial </tag>
            
            <tag> database </tag>
            
            <tag> elasticsearch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Gulp簡易使用教學]]></title>
      <url>https://3rider.com/posts/Gulp%E7%B0%A1%E6%98%93%E4%BD%BF%E7%94%A8%E6%95%99%E5%AD%B8/</url>
      <content type="html"><![CDATA[<p>Gulp這神器完全是為了我們這懶人而設的，用了它之後開發速度快了一倍以上！而且它精簡的結構是其它工具（Grunt、Webpack…）無法與之相比的，以下為大家介紹常用的功能  </p>
<h2 id="一﹒安裝Gulp"><a href="#一﹒安裝Gulp" class="headerlink" title="一﹒安裝Gulp"></a>一﹒安裝Gulp</h2><p>Gulp需要Node.js才能運作，沒有Node可以看這篇<a href="/posts/26">Node安裝教學</a>，然後再用NPM安裝Gulp</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">npm install gulp -g
</code></pre>
<h2 id="二﹒gulpfile-js設定檔"><a href="#二﹒gulpfile-js設定檔" class="headerlink" title="二﹒gulpfile.js設定檔"></a>二﹒gulpfile.js設定檔</h2><p>Gulp會自動讀取路徑內的<code>gulpfile.{ext}</code>設定檔，而這個檔案需要自行建立，我們先建立<code>gulpfile.js</code></p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">touch gulpfile.js
</code></pre>
<h2 id="三﹒使用Gulp指令"><a href="#三﹒使用Gulp指令" class="headerlink" title="三﹒使用Gulp指令"></a>三﹒使用Gulp指令</h2><p>之前我們在全域安裝了gulp，所以我們可以在<code>Terminal</code>內用<code>gulp</code>的指令，指令是根據<code>gulpfile.js</code>內的<code>task</code>（任務）而定的，所以我們可以自行加入新指令，很方便吧？默認的指令是<code>default</code></p>
<p></p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="js">var gulp = require(&#39;gulp&#39;);

gulp.task(&#39;default&#39;, function () {
  console.log(&#39;Hello!&#39;);
});
</code></pre>
<p>現在我們還未可以執行指令，我們需要在路徑內再次安裝<code>gulp</code></p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">npm install gulp
</code></pre>
<p>到這裡終於可以執行了！輸入<code>gulp</code>運行默認的<code>task</code></p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">gulp
</code></pre>
<p>輸出大概是這樣</p>
<p></p><p class="code-caption" data-lang="" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code>[13:29:26] Using gulpfile ~/projects/gulp-example/gulpfile.js
[13:29:26] Starting &#39;default&#39;...
Hello!
[13:29:26] Finished &#39;default&#39; after 104 μs
</code></pre><h2 id="四﹒自定指令名稱"><a href="#四﹒自定指令名稱" class="headerlink" title="四﹒自定指令名稱"></a>四﹒自定指令名稱</h2><p>當然我們可以自定指令的名稱，除了<code>default</code>以外的<code>task</code>都會以<code>gulp {task}</code>的指令運作，就以上的例子我們改成這裡</p>
<p></p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="js">var gulp = require(&#39;gulp&#39;);

gulp.task(&#39;greeting&#39;, function () {
  console.log(&#39;Hello!&#39;);
});
</code></pre>
<p>我們把<code>task</code>改成<code>greeting</code>，換言之指令就會變成這樣</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">gulp greeting
</code></pre>
<h2 id="五﹒三個主要函数"><a href="#五﹒三個主要函数" class="headerlink" title="五﹒三個主要函数"></a>五﹒三個主要函数</h2><ol>
<li>Source<br>設定來源的<code>globs</code>，可以用<code>Array</code>包含多個<code>globs</code>，亦可以用<code>!</code>排除<br><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="js">gulp.src(&#39;index.js&#39;);
gulp.src(&#39;**/*.js&#39;);
gulp.src([&#39;**/*.js&#39;, &#39;!index.js&#39;])
</code></pre>
&nbsp;</li>
<li>Pipeline<br>包含了主要的工作，例如編譯scss然後minify，這些都需要額外模組執行<br><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="js">gulp.src(&#39;scss/*.scss&#39;)
 .pipe(scss())
 .pipe(minify());
</code></pre>
&nbsp;</li>
<li>Destination<br>設定輸出位置<br><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><pre><code class="js">gulp.src(&#39;scss/*.scss&#39;)
 .pipe(scss())
 .pipe(minify())
 .pipe(gulp.dest(&#39;build/css&#39;));
</code></pre>
</li>
</ol>
<h2 id="六﹒常用的Gulp插件"><a href="#六﹒常用的Gulp插件" class="headerlink" title="六﹒常用的Gulp插件"></a>六﹒常用的Gulp插件</h2><p>Gulp的插件真的非常多沒辦法逐一介紹，以下列出一些我常用的插件讓大家參考</p>
<ul>
<li><a href="https://www.npmjs.com/package/gulp-watch" target="_blank" rel="external">gulp-watch</a></li>
<li><a href="https://www.npmjs.com/package/gulp-plumber" target="_blank" rel="external">gulp-plumber</a></li>
<li><a href="https://www.npmjs.com/package/gulp-connect" target="_blank" rel="external">gulp-connect</a></li>
<li><a href="https://www.npmjs.com/package/gulp-livereload" target="_blank" rel="external">gulp-livereload</a></li>
<li><a href="https://www.npmjs.com/package/gulp-sass" target="_blank" rel="external">gulp-sass</a></li>
<li><a href="https://www.npmjs.com/package/gulp-sourcemaps" target="_blank" rel="external">gulp-sourcemaps</a></li>
<li><a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="external">gulp-uglify</a></li>
<li><a href="https://www.npmjs.com/package/gulp-clean-css" target="_blank" rel="external">gulp-clean-css</a></li>
<li><a href="https://www.npmjs.com/package/gulp-concat" target="_blank" rel="external">gulp-concat</a></li>
<li><a href="https://www.npmjs.com/package/gulp-concat-css" target="_blank" rel="external">gulp-concat-css</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> tech </tag>
            
            <tag> tutorial </tag>
            
            <tag> Node.js </tag>
            
            <tag> gulp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Node.js簡易安裝教學]]></title>
      <url>https://3rider.com/posts/Nodejs%E7%B0%A1%E6%98%93%E5%AE%89%E8%A3%9D%E6%95%99%E5%AD%B8/</url>
      <content type="html"><![CDATA[<p>Node.js已經流行一段時間了，越來越多工作要求懂得Node.js，還未學會就趕快安裝一個追上潮流吧！</p>
<h2 id="一﹒安裝NVM"><a href="#一﹒安裝NVM" class="headerlink" title="一﹒安裝NVM"></a>一﹒安裝NVM</h2><p>使用<a href="https://github.com/creationix/nvm" target="_blank" rel="external">NVM（Node Version Manager）</a>其中一個好處就是容易安裝，官方的實在太麻煩了…另一個好處是可以<strong>隨時切換版本</strong>，可能現在你還不明白，等到你長大後自然就會懂了（謎の聲：你是我老爸嗎？）</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.0/install.sh | bash`

export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm
</code></pre>
<h2 id="二﹒安裝Node-js"><a href="#二﹒安裝Node-js" class="headerlink" title="二﹒安裝Node.js"></a>二﹒安裝Node.js</h2><p>然後我們就可以用NVM安裝Node.js了，我們可以用<code>ls-remote</code>查詢可以安裝的版本，沒特別要求就用LTS（Long term support）版本吧</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">nvm ls-remote
nvm install 6
</code></pre>
<h2 id="三﹒編寫第一個Hello-World程式"><a href="#三﹒編寫第一個Hello-World程式" class="headerlink" title="三﹒編寫第一個Hello World程式"></a>三﹒編寫第一個Hello World程式</h2><p>學一種語言最快的方法就是Hello World了，隨意到一個地方建立<code>index.js</code>，裡面輸入</p>
<p></p><p class="code-caption" data-lang="js" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="js">console.log(&#39;hello world!&#39;)
</code></pre>
<p>最後開啟你的Terminal，執行node index.js看結果吧！</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">node index.js
</code></pre>
<h2 id="四﹒解決Node-JS-Error-ENOSPC的問題"><a href="#四﹒解決Node-JS-Error-ENOSPC的問題" class="headerlink" title="四﹒解決Node.JS Error: ENOSPC的問題"></a>四﹒解決Node.JS Error: ENOSPC的問題</h2><p>這是初次裝Node.js很常見的問題，在Terminal執行以下指令就可以解決了</p>
<p></p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span></p><p></p>
<pre><code class="bash">echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p
</code></pre>
]]></content>
      
        
        <tags>
            
            <tag> tech </tag>
            
            <tag> tutorial </tag>
            
            <tag> Node.js </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
